# Use the built-in font to draw a grapheme to real screen.
#
# We need to do this in machine code because Mu doesn't have global variables
# yet (for the start of video memory).

== code

draw-grapheme-on-real-screen:  # g: grapheme, x: int, y: int, color: int
    # . prologue
    55/push-ebp
    89/<- %ebp 4/r32/esp
    # . save registers
    50/push-eax
    51/push-ecx
    52/push-edx
    53/push-ebx
    56/push-esi
    # var letter-bitmap/esi = font[g]
    8b/-> *(ebp+8) 6/r32/esi
    c1 4/subop/shift-left %esi 4/imm8
    8d/copy-address *(esi+0x8800) 6/r32/esi  # font-start
    # if (letter-bitmap >= 0x9000) return  # characters beyond ASCII currently not supported
    81 7/subop/compare %esi 0x9000/imm32
    7d/jump-if->= $draw-grapheme-on-real-screen:end/disp8
    # edx = y
    8b/-> *(ebp+0x10) 2/r32/edx
    # var ymax/ebx: int = y + 16
    8b/-> *(ebp+0x10) 3/r32/ebx
    81 0/subop/add %ebx 0x10/imm32
    {
      # if (y >= ymax) break
      39/compare %edx 3/r32/ebx
      7d/jump-if->= break/disp8
      # eax = x + 7
      8b/-> *(ebp+0xc) 0/r32/eax  # font-width - 1
      81 0/subop/add %eax 7/imm32
      # var xmin/ecx: int = x
      8b/-> *(ebp+0xc) 1/r32/ecx
      # var row-bitmap/ebx: int = *letter-bitmap
      53/push-ebx
      8b/-> *esi 3/r32/ebx
      {
        # if (x < xmin) break
        39/compare %eax 1/r32/ecx
        7c/jump-if-< break/disp8
        # shift LSB from row-bitmap into carry flag (CF)
        c1 5/subop/shift-right-logical %ebx 1/imm8
        # if LSB, draw a pixel
        {
          73/jump-if-not-CF break/disp8
          (pixel-on-real-screen %eax %edx *(ebp+0x14))
          eb/jump $draw-grapheme-on-real-screen:continue/disp8
        }
        # otherwise draw a black pixel
        (pixel-on-real-screen %eax %edx 0)
$draw-grapheme-on-real-screen:continue:
        # --x
        48/decrement-eax
        #
        eb/jump loop/disp8
      }
      # reclaim row-bitmap
      5b/pop-to-ebx
      # ++y
      42/increment-edx
      # next bitmap row
      46/increment-esi
      #
      eb/jump loop/disp8
    }
$draw-grapheme-on-real-screen:end:
    # . restore registers
    5e/pop-to-esi
    5b/pop-to-ebx
    5a/pop-to-edx
    59/pop-to-ecx
    58/pop-to-eax
    # . epilogue
    89/<- %esp 5/r32/ebp
    5d/pop-to-ebp
    c3/return

cursor-position-on-real-screen:  # -> _/eax: int, _/ecx: int
    # . prologue
    55/push-ebp
    89/<- %ebp 4/r32/esp
    # TODO: support fake screen; we currently assume 'screen' is always 0 (real)
    8b/-> *Default-next-x 0/r32/eax
    8b/-> *Default-next-y 1/r32/ecx
$cursor-position-on-real-screen:end:
    # . epilogue
    89/<- %esp 5/r32/ebp
    5d/pop-to-ebp
    c3/return

set-cursor-position-on-real-screen:  # x: int, y: int
    # . prologue
    55/push-ebp
    89/<- %ebp 4/r32/esp
    # . save registers
    50/push-eax
    # TODO: support fake screen; we currently assume 'screen' is always 0 (real)
    8b/-> *(ebp+8) 0/r32/eax
    89/<- *Default-next-x 0/r32/eax
    8b/-> *(ebp+0xc) 0/r32/eax
    89/<- *Default-next-y 0/r32/eax
$set-cursor-position-on-real-screen:end:
    # . restore registers
    58/pop-to-eax
    # . epilogue
    89/<- %esp 5/r32/ebp
    5d/pop-to-ebp
    c3/return

== data

Default-next-x:
  0/imm32

Default-next-y:
  0/imm32
