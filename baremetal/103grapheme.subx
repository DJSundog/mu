draw-grapheme:  # screen: (addr screen), g: grapheme, x: int, y: int, color: int
    # . prologue
    55/push-ebp
    89/<- %ebp 4/r32/esp
    # . save registers
    50/push-eax
    51/push-ecx
    52/push-edx
    53/push-ebx
    56/push-esi
    # TODO: support fake screen; we currently assume 'screen' is always 0 (real)
    # var letter-bitmap/esi = font[g]
    8b/-> *(ebp+0xc) 6/r32/esi
    c1 4/subop/shift-left %esi 4/imm8
    8d/copy-address *(esi+0x8800) 6/r32/esi  # font-start
    # if (letter-bitmap >= 0x9000) return  # characters beyond ASCII currently not supported
    81 7/subop/compare %esi 0x9000/imm32
    7d/jump-if->= $draw-grapheme:end/disp8
    # edx = y
    8b/-> *(ebp+0x14) 2/r32/edx
    # var ymax/ebx: int = y + 16
    8b/-> *(ebp+0x14) 3/r32/ebx
    81 0/subop/add %ebx 0x10/imm32
    {
      # if (y >= ymax) break
      39/compare %edx 3/r32/ebx
      7d/jump-if->= break/disp8
      # eax = x + 7
      8b/-> *(ebp+0x10) 0/r32/eax
      81 0/subop/add %eax 7/imm32
      # var xmin/ecx: int = x
      8b/-> *(ebp+0x10) 1/r32/ecx
      # var row-bitmap/ebx: int = *letter-bitmap
      53/push-ebx
      8b/-> *esi 3/r32/ebx
      {
        # if (x < xmin) break
        39/compare %eax 1/r32/ecx
        7c/jump-if-< break/disp8
        # shift LSB from row-bitmap into carry flag (CF)
        c1 5/subop/shift-right-logical %ebx 1/imm8
        # if LSB, draw a pixel
        {
          73/jump-if-not-CF break/disp8
          (pixel *(ebp+8) %eax %edx *(ebp+0x18))
        }
        # --x
        48/decrement-eax
        #
        eb/jump loop/disp8
      }
      # reclaim row-bitmap
      5b/pop-to-ebx
      # ++y
      42/increment-edx
      # next bitmap row
      46/increment-esi
      #
      eb/jump loop/disp8
    }
$draw-grapheme:end:
    # . restore registers
    5e/pop-to-esi
    5b/pop-to-ebx
    5a/pop-to-edx
    59/pop-to-ecx
    58/pop-to-eax
    # . epilogue
    89/<- %esp 5/r32/ebp
    5d/pop-to-ebp
    c3/return

cursor-position:  # screen: (addr screen) -> _/eax: int, _/ecx: int
    # . prologue
    55/push-ebp
    89/<- %ebp 4/r32/esp
    # TODO: support fake screen; we currently assume 'screen' is always 0 (real)
    8b/-> *Default-next-x 0/r32/eax
    8b/-> *Default-next-y 1/r32/ecx
$cursor-position:end:
    # . epilogue
    89/<- %esp 5/r32/ebp
    5d/pop-to-ebp
    c3/return

set-cursor-position:  # screen: (addr screen), x: int, y: int
    # . prologue
    55/push-ebp
    89/<- %ebp 4/r32/esp
    # . save registers
    50/push-eax
    # TODO: support fake screen; we currently assume 'screen' is always 0 (real)
    8b/-> *(ebp+0xc) 0/r32/eax
    89/<- *Default-next-x 0/r32/eax
    8b/-> *(ebp+0x10) 0/r32/eax
    89/<- *Default-next-y 0/r32/eax
$set-cursor-position:end:
    # . restore registers
    58/pop-to-eax
    # . epilogue
    89/<- %esp 5/r32/ebp
    5d/pop-to-ebp
    c3/return

== data

Default-next-x:
  0/imm32

Default-next-y:
  0/imm32
