## add the first 10 numbers

== 0x08048054  # code segment, after leaving room for ELF header
# opcode        ModR/M                    SIB                   displacement    immediate
# instruction   mod, reg, Reg/Mem bits    scale, index, base
# 1-3 bytes     0/1 byte                  0/1 byte              0/1/2/4 bytes   0/1/2/4 bytes
  # result: EBX = 0
# 0: e_entry = 0x08048054
  bb                                                                            0/imm32       # copy 0 to EBX
  # counter: ECX = 1
  b9                                                                            1/imm32       # copy 1 to ECX

# 10: loop: 0x0804805e
  # while (ECX <= 10)
  81            f9                                                              10/imm32      # compare ECX, 10/imm
  7f                                                            0a                            # jump-if-greater exit (+10)
  # EBX += ECX
  01            cb                                                                            # add ECX to EBX
  # ECX++
  81            c1                                                              1/imm32       # add 1 to ECX
  # loop
  eb                                                            ee                            # jump loop (-18; -00010010; 11101110)

# 28: exit: 0x08048070
  # exit(EBX)
  b8                                                                            1/imm32       # copy 1 to EAX
  cd                                                                            128/imm8      # int 80h

# vim:ft=subx:nowrap
