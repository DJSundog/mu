## port of https://github.com/akkartik/crenshaw/blob/master/tutor2.1.pas
# corresponds to the section "single digits" in https://compilers.iecc.com/crenshaw/tutor2.txt
#
# To run (from the subx directory):
#   $ ./subx translate *.subx apps/crenshaw2-1.subx -o crenshaw2-1
#   $ echo '3'  |./subx run apps/crenshaw2-1
# Expected output (not working yet):
#   # syscall(exit, 3)
#   bb/copy-to-EBX  3/imm32
#   b8/copy-to-EAX  1/imm32/exit
#   cd/syscall  0x80/imm8
#
# To run the generated output:
#   $ echo '3'  |./subx run apps/crenshaw2-1 > z1.subx
#   $ ./subx translate z1.subx -o z1
#   $ ./z1
#   $ echo $?
#   3
#
# Stdin must contain just a single hex number. Other input will print an error:
#   $ echo 'xyz'  |./subx run apps/crenshaw2-1
#   Error: integer expected

== code
# instruction                     effective address                                                   operand     displacement    immediate
# op          subop               mod             rm32          base        index         scale       r32
# 1-3 bytes   3 bits              2 bits          3 bits        3 bits      3 bits        2 bits      2 bits      0/1/2/4 bytes   0/1/2/4 bytes

# main:
  # allocate space for an exit-descriptor
  # var ed/EAX : (address exit-descriptor)
  81          5/subop/subtract    3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # subtract from ESP
  8d/copy-address                 0/mod/indirect  4/rm32/sib    4/base/ESP  4/index/none  .           0/r32/EAX   .               .                 # copy ESP to EAX
  # clear ed->target (so we really exit)
  c7/copy                         0/mod/direct    0/rm32/EAX    .           .             .           .           .               0/imm32           # copy to *EAX
  # expected(ed, 2/stderr, "integer")
    # push args
  68/push  "integer"/imm32
  68/push  2/imm32/stderr
  50/push-EAX
    # call
  e8/call  expected/disp32
    # discard args
  81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
  # syscall(exit, 0)
  bb/copy-to-EBX  0/imm32
  b8/copy-to-EAX  1/imm32/exit
  cd/syscall  0x80/imm8

## helpers

expected:  # ed : (address exit-descriptor), f : fd or (address stream), s : (address array byte)
  # prolog
  55/push-EBP
  89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
  # write(f, "Error: ")
    # push args
  68/push  "Error: "/imm32
  ff          6/subop/push        1/mod/*+disp8   4/rm32/sib    5/base/EBP  4/index/none  .           .           0xc/disp8       .                 # push *(EBP+12)
    # call
  e8/call  write/disp32
    # discard args
  81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
  # write(f, s)
    # push args
  ff          6/subop/push        1/mod/*+disp8   4/rm32/sib    5/base/EBP  4/index/none  .           .           0x10/disp8      .                 # push *(EBP+16)
  ff          6/subop/push        1/mod/*+disp8   4/rm32/sib    5/base/EBP  4/index/none  .           .           0xc/disp8       .                 # push *(EBP+12)
    # call
  e8/call  write/disp32
    # discard args
  81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
  # write(f, " expected")
    # push args
  68/push  " expected"/imm32
  ff          6/subop/push        1/mod/*+disp8   4/rm32/sib    5/base/EBP  4/index/none  .           .           0xc/disp8       .                 # push *(EBP+12)
    # call
  e8/call  write/disp32
    # discard args
  81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
  # write(f, Newline)
    # push args
  68/push  Newline/imm32
  ff          6/subop/push        1/mod/*+disp8   4/rm32/sib    5/base/EBP  4/index/none  .           .           0xc/disp8       .                 # push *(EBP+12)
    # call
  e8/call  write/disp32
    # discard args
  81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
  # stop(ed, 1)
    # push args
  68/push  1/imm32
  ff          6/subop/push        1/mod/*+disp8   4/rm32/sib    5/base/EBP  4/index/none  .           .           8/disp8         .                 # push *(EBP+8)
    # call
  e8/call  stop/disp32
  ## should never get past this point
  # epilog
  89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
  5d/pop-to-EBP
  c3/return

# vim:nowrap:textwidth=0
