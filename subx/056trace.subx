# primitives for emitting traces to a 'trace' stream, and for tests to make assertions on its contents
#
# A trace stream looks like a regular stream:
#   write : int  # index at which writes go
#   read : int  # index that we've read until
#   data : (array byte)  # prefixed by length as usual
# Usually the trace stream will be in a separate segment set aside for the purpose.
#
# primitives for operating on traces (arguments in quotes):
#   - initialize-trace-stream: populates Trace-stream with a new segment of the given 'size'
#   - trace: adds a 'line' to Trace-stream
#   - check-trace-contains: scans from Trace-stream's start for a matching 'line', prints a 'message' to stderr on failure
#   - check-trace-scans-to: scans from Trace-stream's read pointer for a matching 'line', prints a 'message' to stderr on failure

== data

# We'll save the address of the trace segment here.
Trace-stream:
    0/imm32

Trace-segment:
    0/imm32/curr
    0/imm32/end

# Fake trace-stream for tests.
# Also illustrates the layout of the real trace-stream (segment).
_test-trace-stream:
    # current write index
    0/imm32
    # current read index
    0/imm32
    # length
    8/imm32
    # data
    00 00 00 00 00 00 00 00  # 8 bytes

_test-stream-with-newline:
    # current write index
    0/imm32
    # current read index
    0/imm32
    # length
    8/imm32
    # data
    41 41 41 41 0A 41 41 41  # 8 bytes

_test-stream-line-match:
    # current write index
    8/imm32
    # current read index
    0/imm32
    # length
    8/imm32
    # data
    41 42 41 42 41 0A 00 00  # 8 bytes

== code
#   instruction                     effective address                                                   register    displacement    immediate
# . op          subop               mod             rm32          base        index         scale       r32
# . 1-3 bytes   3 bits              2 bits          3 bits        3 bits      3 bits        2 bits      2 bits      0/1/2/4 bytes   0/1/2/4 bytes

# Allocate a new segment for the trace stream, initialize its length, and save its address to Trace-stream.
# The Trace-stream segment will consist of variable-length lines separated by newlines (0x0a)
initialize-trace-stream:  # n : int -> <void>
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    50/push-EAX
    51/push-ECX
    # ECX = n
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .             .           1/r32/ECX   8/disp8         .                 # copy *(EBP+8) to ECX
    # Trace-segment = new-segment(n)
    # . . push args
    68/push  Trace-segment/imm32
    51/push-ECX
    # . . call
    e8/call  new-segment/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
    # copy Trace-segment->curr to *Trace-stream
    8b/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-segment/disp32              # copy *Trace-segment to EAX
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy EAX to *Trace-stream
    # Trace-stream->length = n - 12
    # . ECX -= 12
    81          5/subop/subtract    3/mod/direct    1/rm32/ECX    .           .             .           .           .               0xc/imm32         # subtract from ECX
    # . Trace-stream->length = ECX
    89/copy                         1/mod/*+disp8   0/rm32/EAX    .           .             .           1/r32/ECX   8/disp8         .                 # copy ECX to *(EAX+8)
$initialize-trace-stream:end:
    # . restore registers
    59/pop-to-ECX
    58/pop-to-EAX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

# Append a string to the given trace stream.
# Silently give up if it's already full. Or truncate the string if there isn't enough room.
trace:  # line : string
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    50/push-EAX
    51/push-ECX
    52/push-EDX
    53/push-EBX
    56/push-ESI
    57/push-EDI
    # EDI = *Trace-stream
    8b/copy                         0/mod/indirect  5/rm32/.disp32            .             .           7/r32/EDI   Trace-stream/disp32               # copy *Trace-stream to EDI
    # ESI = line
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .                         6/r32/ESI   8/disp8         .                 # copy *(EBP+8) to ESI
    # ECX = t->write
    8b/copy                         0/mod/indirect  7/rm32/EDI    .           .             .           1/r32/ECX   .               .                 # copy *EDI to ECX
    # EDX = t->length
    8b/copy                         1/mod/*+disp8   7/rm32/EDI    .           .             .           2/r32/EDX   8/disp8         .                 # copy *(EDI+8) to EDX
    # EAX = _append-3(&t->data[t->write], &t->data[t->length], line)
    # . . push line
    56/push-ESI
    # . . push &t->data[t->length]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    7/base/EDI  2/index/EDX   .           3/r32/EBX   0xc/disp8       .                 # copy EDI+EDX+12 to EBX
    53/push-EBX
    # . . push &t->data[t->write]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    7/base/EDI  1/index/ECX   .           3/r32/EBX   0xc/disp8       .                 # copy EDI+ECX+12 to EBX
    53/push-EBX
    # . . call
    e8/call  _append-3/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # if (EAX == 0) return
    3d/compare-EAX-and  0/imm32
    74/jump-if-equal  $trace:end/disp8
    # t->write += EAX
    01/add                          0/mod/indirect  7/rm32/EDI    .           .             .           0/r32/EAX   .               .                 # add EAX to *EDI
    # refresh ECX = t->write
    8b/copy                         0/mod/indirect  7/rm32/EDI    .           .             .           1/r32/ECX   .               .                 # copy *EDI to ECX
    # EAX = _append-3(&t->data[t->write], &t->data[t->length], line)
    # . . push line
    68/push  Newline/imm32
    # . . push &t->data[t->length]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    7/base/EDI  2/index/EDX   .           3/r32/EBX   0xc/disp8       .                 # copy EDI+EDX+12 to EBX
    53/push-EBX
    # . . push &t->data[t->write]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    7/base/EDI  1/index/ECX   .           3/r32/EBX   0xc/disp8       .                 # copy EDI+ECX+12 to EBX
    53/push-EBX
    # . . call
    e8/call  _append-3/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # t->write += EAX
    01/add                          0/mod/indirect  7/rm32/EDI    .           .             .           0/r32/EAX   .               .                 # add EAX to *EDI
$trace:end:
    # . restore registers
    5f/pop-to-EDI
    5e/pop-to-ESI
    5b/pop-to-EBX
    5a/pop-to-EDX
    59/pop-to-ECX
    58/pop-to-EAX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

test-trace-single:
    # *Trace-stream = _test-trace-stream
    b8/copy-to-EAX  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy EAX to *Trace-stream
    # clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # check-ints-equal(*_test-trace-stream->data, 41/A 62/b 0a/newline 00, msg)
    # . . push args
    68/push  "F - test-trace-single"/imm32
    68/push  0x0a6241/imm32/Ab-newline
    # . . push *_test-trace-stream->data
    b8/copy-to-EAX  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/EAX    .           .             .           .           0xc/disp8       .                 # push *(EAX+12)
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # end
    c3/return

test-trace-appends:
    # *Trace-stream = _test-trace-stream
    b8/copy-to-EAX  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy EAX to *Trace-stream
    # clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # trace("C")
    # . . push args
    68/push  "C"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # trace("D")
    # . . push args
    68/push  "D"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # check-ints-equal(*_test-trace-stream->data, 43/C 0a/newline 44/D 0a/newline, msg)
    # . . push args
    68/push  "F - test-trace-appends"/imm32
    68/push  0x0a440a43/imm32/C-newline-D-newline
    # . . push *_test-trace-stream->data
    b8/copy-to-EAX  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/EAX    .           .             .           .           0xc/disp8       .                 # push *(EAX+12)
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # end
    c3/return

test-trace-empty-line:
    # *Trace-stream = _test-trace-stream
    b8/copy-to-EAX  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy EAX to *Trace-stream
    # clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # trace("")
    # . . push args
    68/push  ""/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # check-ints-equal(*_test-trace-stream->data, 0, msg)
    # . . push args
    68/push  "F - test-trace-empty-line"/imm32
    68/push  0/imm32
    # . . push *_test-trace-stream->data
    b8/copy-to-EAX  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/EAX    .           .             .           .           0xc/disp8       .                 # push *(EAX+12)
    # . . call
    e8/call  check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # end
    c3/return

check-trace-contains:  # line : (address string), msg : (address string)
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # rewind-stream(*Trace-stream)
    # . . push args
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Segment-size
    # . . call
    e8/call  rewind-stream/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # check-trace-scans-to(line, msg)
    # . . push args
    ff          6/subop/push        1/mod/*+disp8   5/rm32/EBP    .           .             .           .           0xc/disp8       .                 # push *(EBP+12)
    ff          6/subop/push        1/mod/*+disp8   5/rm32/EBP    .           .             .           .           8/disp8         .                 # push *(EBP+8)
    # . . call
    e8/call  check-trace-scans-to/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
$check-trace-contains:end:
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

check-trace-scans-to:  # line : (address string), msg : (address string)
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    50/push-EAX
    # EAX = trace-scan(*Trace-stream, line)
    # . . push args
    ff          6/subop/push        1/mod/*+disp8   5/rm32/EBP    .           .             .           .           8/disp8         .                 # push *(EBP+8)
    ff          6/subop/push        0/mod/indirect  5/rm32/.disp32            .             .           .           Trace-stream/disp32               # push *Segment-size
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
    # check-ints-equal(EAX, 1, msg)
    # . . push args
    ff          6/subop/push        1/mod/*+disp8   5/rm32/EBP    .           .             .           .           0xc/disp8       .                 # push *(EBP+12)
    68/push  1/imm32
    50/push-EAX
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
$check-trace-scans-to:end:
    # . restore registers
    58/pop-to-EAX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

# Start scanning from Trace-stream->read for 'line'. If found, update Trace-stream->read and return true.
trace-scan:  # line : string -> result/EAX : boolean
    # pseudocode:
    #   while true:
    #     if Trace-stream->read >= Trace-stream->write
    #       break
    #     if next-line-matches?(Trace-stream, line)
    #       skip-next-line(Trace-stream)
    #       return true
    #   return false
    #
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    51/push-ECX
    56/push-ESI
    # ESI = *Trace-stream
    8b/copy                         0/mod/indirect  5/rm32/.disp32            .             .           6/r32/ESI   Trace-stream/disp32               # copy *Trace-stream to ESI
    # ECX = Trace-stream->write
    8b/copy                         0/mod/indirect  6/rm32/ESI    .           .             .           1/r32/ECX                   .                 # copy *ESI to ECX
$trace-scan:loop:
    # if (Trace-stream->read >= Trace-stream->write) return false
    39/compare                      1/mod/*+disp8   6/rm32/ESI    .           .             .           1/r32/ECX   4/disp8         .                 # compare ECX with *(ESI+4)
    7d/jump-if-greater-or-equal  $trace-scan:false/disp8
    # EAX = next-line-matches?(Trace-stream, line)
    # . . push args
    ff          6/subop/push        1/mod/*+disp8   5/rm32/EBP    .           .             .           .           8/disp8         .                 # push *(EBP+8)
    56/push-ESI
    # . . call
    e8/call  next-line-matches?/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
    # if (EAX == 0) continue
    3d/compare-EAX-and  0/imm32
    74/jump-if-equal  $trace-scan:loop/disp8
$trace-scan:true:
    # skip-next-line(Trace-stream)
    # . . push args
    56/push-ESI
    # . . call
    e8/call  skip-next-line/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # return true
    b8/copy-to-EAX  1/imm32/true
    eb/jump  $trace-scan:end/disp8
$trace-scan:false:
    b8/copy-to-EAX  0/imm32/false
$trace-scan:end:
    # . restore registers
    59/pop-to-ECX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

next-line-matches?:  # t : (address stream), line : string -> result/EAX : boolean
    # pseudocode:
    #   while true:
    #     if (currl >= maxl) break
    #     if (currt >= maxt) return false
    #     if (*currt != *currl) return false
    #     ++currt
    #     ++currl
    #   return *currt == '\n'
    #
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    51/push-ECX
    52/push-EDX
    53/push-EBX
    56/push-ESI
    57/push-EDI
    # EDX = line
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .                         2/r32/EDX   0xc/disp8       .                 # copy *(EBP+12) to EDX
    # currl/ESI = line->data
    # . ESI = line/EDX->data
    8d/copy-address                 1/mod/*+disp8   2/rm32/EDX    .           .             .           6/r32/ESI   4/disp8         .                 # copy EDX+4 to ESI
    # maxl/ECX = line->data + line->size
    # . EAX = line/EDX->size
    8b/copy                         0/mod/indirect  2/rm32/EDX    .           .                         0/r32/EAX   .               .                 # copy *EDX to EAX
    # . maxl/ECX = line->data/ESI + line->size/EAX
    8d/copy-address                 0/mod/indirect  4/rm32/sib    6/base/ESI  0/index/EAX   .           1/r32/ECX   .               .                 # copy EDX+EAX to ECX
    # EDI = t
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .                         7/r32/EDI   8/disp8         .                 # copy *(EBP+8) to EDI
    # EBX = t->data
    8d/copy-address                 1/mod/*+disp8   7/rm32/EDI    .           .             .           3/r32/EBX   0xc/disp8       .                 # copy EDI+12 to EBX
    # maxt/EDX = t->data + t->write
    # . EAX = t->write
    8b/copy                         0/mod/indirect  7/rm32/EDI    .           .                         0/r32/EAX   .               .                 # copy *EDI to EAX
    # . maxt/EDX = t->data/EBX + t->write/EAX
    8d/copy-address                 0/mod/indirect  4/rm32/sib    3/base/EBX  0/index/EAX   .           2/r32/EDX   .               .                 # copy EBX+EAX to EDX
    # currt/EDI = t->data + t->read
    # . EAX = t/EDI->read
    8b/copy                         1/mod/*+disp8   7/rm32/EDI    .           .                         0/r32/EAX   4/disp8         .                 # copy *(EDI+4) to EAX
    # . currt/EDI = t->data/EBX + t->read/EAX
    8d/copy-address                 0/mod/indirect  4/rm32/sib    3/base/EBX  0/index/EAX   .           7/r32/EDI   .               .                 # copy EBX+EAX to EDI
$next-line-matches?:loop:
    # if (currl/ESI >= maxl/ECX) break
    39/compare                      3/mod/direct    6/rm32/ESI    .           .             .           1/r32/ECX   .               .                 # compare ESI and ECX
    7d/jump-if-greater-or-equal  $next-line-matches?:break/disp8
    # if (currt/EDI >= maxt/EDX) return false
    # . EAX = false
    b8/copy-to-EAX  0/imm32/false
    39/compare                      3/mod/direct    7/rm32/EDI    .           .             .           2/r32/EDX   .               .                 # compare EDI and EDX
    7d/jump-if-greater-or-equal  $next-line-matches?:end/disp8
    # if (*currt/EDI != *currl/ESI) return false
    31/xor                          3/mod/direct    0/rm32/EAX    .           .             .           0/r32/EAX   .               .                 # clear EAX
    31/xor                          3/mod/direct    3/rm32/EAX    .           .             .           3/r32/EAX   .               .                 # clear EBX
    # . EAX = (char) *currt/EDI
    8a/copy-byte                    0/mod/indirect  7/rm32/EDI    .           .                         0/r32/EAX   .               .                 # copy *EDI to EAX
    # . EBX = (char) *currl/ESI
    8a/copy-byte                    0/mod/indirect  6/rm32/ESI    .           .                         3/r32/EBX   .               .                 # copy *ESI to EBX
    # . EAX >= EBX
    39/compare                      3/mod/direct    0/rm32/EAX    .           .             .           3/r32/EBX   .               .                 # compare EAX and EBX
    # . EAX = false
    b8/copy-to-EAX  0/imm32/false
    75/jump-if-not-equal  $next-line-matches?:end/disp8
    # ++currt/EDI
    47/increment-EDI
    # ++currl/ESI
    46/increment-ESI
    eb/jump  $next-line-matches?:loop/disp8
$next-line-matches?:break:
    # return *currt == '\n'
    31/xor                          3/mod/direct    0/rm32/EAX    .           .             .           0/r32/EAX   .               .                 # clear EAX
    # . EAX = (char) *currt
    8a/copy-byte                    0/mod/indirect  7/rm32/EDI    .           .                         0/r32/EAX   .               .                 # copy *EDI to EAX
    3d/compare-EAX-and  0xa/imm32/newline
    # . EAX = false
    b8/copy-to-EAX  1/imm32/true
    74/jump-if-equal  $next-line-matches?:end/disp8
    b8/copy-to-EAX  0/imm32/true
$next-line-matches?:end:
    # . restore registers
    5f/pop-to-EDI
    5e/pop-to-ESI
    5b/pop-to-EBX
    5a/pop-to-EDX
    59/pop-to-ECX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

test-next-line-matches?:
$test-next-line-matches?:no-match-1:
    # EAX = next-line-matches?(_test-stream-line-match, "blah blah")
    68/push  "blah blah"/imm32
    68/push  _test-stream-line-match/imm32
    e8/call  next-line-matches?/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
    # check-ints-equal(EAX, 0, msg)
    68/push  "F - test-next-line-matches?:no-match-1"/imm32
    68/push  0/imm32
    50/push-EAX
    e8/call  check-ints-equal/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
$test-next-line-matches?:no-match-2:
    # EAX = next-line-matches?(_test-stream-line-match, "")
    68/push  ""/imm32
    68/push  _test-stream-line-match/imm32
    e8/call  next-line-matches?/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
    # check-ints-equal(EAX, 0, msg)
    68/push  "F - test-next-line-matches?:no-match-2"/imm32
    68/push  0/imm32
    50/push-EAX
    e8/call  check-ints-equal/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
$test-next-line-matches?:no-match-3:
    # EAX = next-line-matches?(_test-stream-line-match, "AA")
    68/push  "AA"/imm32
    68/push  _test-stream-line-match/imm32
    e8/call  next-line-matches?/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
    # check-ints-equal(EAX, 0, msg)
    68/push  "F - test-next-line-matches?:no-match-3"/imm32
    68/push  0/imm32
    50/push-EAX
    e8/call  check-ints-equal/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
$test-next-line-matches?:match:
    # EAX = next-line-matches?(_test-stream-line-match, "blah blah")
    68/push  "ABABA"/imm32
    68/push  _test-stream-line-match/imm32
    e8/call  next-line-matches?/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
    # check-ints-equal(EAX, 0, msg)
    68/push  "F - test-next-line-matches?:match"/imm32
    68/push  1/imm32
    50/push-EAX
    e8/call  check-ints-equal/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    c3/return

skip-next-line:  # t : (address stream)
    # pseudocode:
    #   max = t->data + t->write
    #   i = t->read
    #   curr = t->data + t->read
    #   while true
    #     if (curr >= max) break
    #     if (*curr == '\n') break
    #     ++curr
    #     ++i
    #   t->read = i
    #
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    50/push-EAX
    51/push-ECX
    52/push-EDX
    53/push-EBX
    # ECX = t
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .                         1/r32/ECX   8/disp8         .                 # copy *(EBP+8) to ECX
    # EDX = t/ECX->data
    8d/copy-address                 1/mod/*+disp8   1/rm32/ECX    .           .             .           2/r32/EDX   0xc/disp8       .                 # copy ECX+12 to EDX
    # EAX = t/ECX->write
    8b/copy                         0/mod/indirect  1/rm32/ECX    .           .             .           0/r32/EAX   .               .                 # copy *ECX to EAX
    # max/EBX = t->data/EDX + t->write/EAX
    8d/copy-address                 0/mod/indirect  4/rm32/sib    2/base/EDX  0/index/EAX   .           3/r32/EBX   .               .                 # copy EDX+EAX to EBX
    # EAX = t/ECX->read
    8b/copy                         1/mod/*+disp8   1/rm32/ECX    .           .             .           0/r32/EAX   4/disp8         .                 # copy *(ECX+4) to EDX
    # curr/ECX = t->data/EDX + t->read/EAX
    8d/copy-address                 0/mod/indirect  4/rm32/sib    2/base/EDX  0/index/EAX   .           1/r32/ECX   .               .                 # copy EDX+EAX to ECX
    # i/EDX = EAX
    8b/copy                         3/mod/direct    0/rm32/EAX    .           .             .           2/r32/EDX   .               .                 # copy EAX to EDX
$skip-next-line:loop:
    # if (curr/ECX >= max/EBX) break
    39/compare                      3/mod/direct    1/rm32/ECX    .           .             .           3/r32/EBX   .               .                 # compare ECX and EBX
    7d/jump-if-greater-or-equal  $skip-next-line:end/disp8
    # if (*curr/ECX == '\n') break
    31/xor                          3/mod/direct    0/rm32/EAX    .           .             .           0/r32/EAX   .               .                 # clear EAX
    8a/copy-byte                    0/mod/indirect  1/rm32/ECX    .           .             .           0/r32/EAX   .               .                 # copy *ECX to EAX
    3d/compare-EAX-and  0a/imm32/newline
    74/jump-if-equal  $skip-next-line:end/disp8
    # ++curr/ECX
    41/increment-ECX
    # ++i/EDX
    42/increment-EDX
    # loop
    eb/jump  $skip-next-line:loop/disp8
$skip-next-line:end:
    # ECX = t
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .                         1/r32/ECX   8/disp8         .                 # copy *(EBP+8) to ECX
    # t/ECX->read = i/EDX
    89/copy                         1/mod/*+disp8   1/rm32/ECX    .           .             .           2/r32/EDX   4/disp8         .                 # copy EDX to *(ECX+4)
    # . restore registers
    5b/pop-to-EBX
    5a/pop-to-EDX
    59/pop-to-ECX
    58/pop-to-EAX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

test-skip-next-line:
$test-skip-next-line:empty:
    # skip-next-line(_test-stream-with-newline)
    68/push  _test-stream-with-newline/imm32
    e8/call  skip-next-line/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # check-ints-equal(_test-stream-with-newline->read, 0)
    b8/copy-to-EAX  _test-stream-with-newline/imm32
    # . EAX = _test-stream-with-newline/EAX->read
    8b/copy                         1/mod/*+disp8   0/rm32/EAX    .           .             .           0/r32/EAX   4/disp8         .                 # copy *(EAX+4) to EAX
    # . push args
    68/push  "F - test-skip-next-line:empty"/imm32
    68/push  0/imm32
    50/push-EAX
    e8/call  check-ints-equal/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
$test-skip-next-line:filled:
    # _test-stream-with-newline/EAX->write = 8
    b8/copy-to-EAX  _test-stream-with-newline/imm32
    c7          0/subop/copy        0/mod/indirect  0/rm32/EAX    .           .             .           .           .               8/imm32           # copy 8 to *EAX
    # skip-next-line(_test-stream-with-newline/EAX)
    50/push-EAX
    e8/call  skip-next-line/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # . EAX = _test-stream-with-newline/EAX->read
    8b/copy                         1/mod/*+disp8   0/rm32/EAX    .           .             .           0/r32/EAX   4/disp8         .                 # copy *(EAX+4) to EAX
    # check-ints-equal(_test-stream-with-newline->read/EAX, 4)
    68/push  "F - test-skip-next-line:filled"/imm32
    68/push  4/imm32
    50/push-EAX
    e8/call  check-ints-equal/disp32
    # . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    c3/return

test-trace-scan-first:
    # setup
    # . *Trace-stream = _test-trace-stream
    b8/copy-to-EAX  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy EAX to *Trace-stream
    # . clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # . trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # EAX = trace-scan("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # check-ints-equal(EAX, 1, msg)
    # . . push args
    68/push  "F - test-trace-scan-first"/imm32
    68/push  1/imm32
    50/push-EAX
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # . end
    c3/return

test-trace-scan-skips-lines-until-found:
    # setup
    # . *Trace-stream = _test-trace-stream
    b8/copy-to-EAX  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy EAX to *Trace-stream
    # . clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # . trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # . trace("cd")
    # . . push args
    68/push  "cd"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # EAX = trace-scan("cd")
    # . . push args
    68/push  "cd"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # check-ints-equal(EAX, 1, msg)
    # . . push args
    68/push  "F - test-trace-scan-skips-lines-until-found"/imm32
    68/push  1/imm32
    50/push-EAX
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # . end
    c3/return

test-trace-second-scan-starts-where-first-left-off:
    # setup
    # . *Trace-stream = _test-trace-stream
    b8/copy-to-EAX  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy EAX to *Trace-stream
    # . clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # . trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # . EAX = trace-scan("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # second scan fails
    # . EAX = trace-scan("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # check-ints-equal(EAX, 0, msg)
    # . . push args
    68/push  "F - test-trace-second-scan-starts-where-first-left-off"/imm32
    68/push  0/imm32
    50/push-EAX
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # . end
    c3/return

test-trace-scan-failure-leaves-read-index-untouched:
    # setup
    # . *Trace-stream = _test-trace-stream
    b8/copy-to-EAX  _test-trace-stream/imm32
    89/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy EAX to *Trace-stream
    # . clear-trace-stream()
    e8/call  clear-trace-stream/disp32
    # . trace("Ab")
    # . . push args
    68/push  "Ab"/imm32
    # . . call
    e8/call  trace/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # . check-ints-equal(_test-trace-stream->read, 0, msg)
    # . . push args
    68/push  "F - test-trace-second-scan-starts-where-first-left-off/precondition-failure"/imm32
    68/push  0/imm32
    b8/copy-to-EAX  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/EAX    .           .             .           .           4/disp8         .                 # push *(EAX+4)
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # perform a failing scan
    # . EAX = trace-scan("Ax")
    # . . push args
    68/push  "Ax"/imm32
    # . . call
    e8/call  trace-scan/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               4/imm32           # add to ESP
    # no change in read index
    # . check-ints-equal(_test-trace-stream->read, 0, msg)
    # . . push args
    68/push  "F - test-trace-second-scan-starts-where-first-left-off"/imm32
    68/push  0/imm32
    b8/copy-to-EAX  _test-trace-stream/imm32
    ff          6/subop/push        1/mod/*+disp8   0/rm32/EAX    .           .             .           .           4/disp8         .                 # push *(EAX+4)
    # . . call
    e8/call check-ints-equal/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0xc/imm32         # add to ESP
    # . end
    c3/return

clear-trace-stream:
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    50/push-EAX
    51/push-ECX
    # EAX = *Trace-stream
    8b/copy                         0/mod/indirect  5/rm32/.disp32            .             .           0/r32/EAX   Trace-stream/disp32               # copy *Trace-stream to EAX
    # ECX = t->length
    8b/copy                         1/mod/*+disp8   0/rm32/EAX    .           .             .           1/r32/ECX   8/disp8         .                 # copy *(EAX+8) to ECX
    # ECX = &t->data[t->length]
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    0/base/EAX  1/index/ECX   .           1/r32/ECX   0xc/disp8       .                 # copy EAX+ECX+12 to ECX
    # t->write = 0
    c7          0/subop/copy        0/mod/direct    0/rm32/EAX    .           .             .           .           .               0/imm32           # copy to *EAX
    # t->read = 0
    c7          0/subop/copy        1/mod/*+disp8   0/rm32/EAX    .           .             .           .           4/disp8         0/imm32           # copy to *(EAX+4)
    # EAX = t->data
    81          0/subop/add         3/mod/direct    0/rm32/EAX    .           .             .           .           .               0xc/imm32         # add to EAX
$clear-trace-stream:loop:
    # if (EAX >= ECX) break
    39/compare                      3/mod/direct    0/rm32/EAX    .           .             .           1/r32/ECX   .               .                 # compare EAX with ECX
    7d/jump-if-greater-or-equal  $clear-trace-stream:end/disp8
    # *EAX = 0
    c7          0/subop/copy        0/mod/direct    0/rm32/EAX    .           .             .           .           .               0/imm32           # copy to *EAX
    # EAX += 4
    81          0/subop/add         3/mod/direct    0/rm32/EAX    .           .             .           .           .               4/imm32           # add to EAX
    eb/jump  $clear-trace-stream:loop/disp8
$clear-trace-stream:end:
    # . restore registers
    59/pop-to-ECX
    58/pop-to-EAX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

# - helpers

# 3-argument variant of _append
_append-3:  # out : address, outend : address, s : (array byte) -> num_bytes_appended/EAX
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    51/push-ECX
    # EAX = _append-4(out, outend, &s->data[0], &s->data[s->length])
    # . . push &s->data[s->length]
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .                         0/r32/EAX   0x10/disp8      .                 # copy *(EBP+16) to EAX
    8b/copy                         0/mod/indirect  0/rm32/EAX    .           .             .           1/r32/ECX   .               .                 # copy *EAX to ECX
    8d/copy-address                 1/mod/*+disp8   4/rm32/sib    0/base/EAX  1/index/ECX   .           1/r32/ECX   4/disp8         .                 # copy EAX+ECX+4 to ECX
    51/push-ECX
    # . . push &s->data[0]
    8d/copy-address                 1/mod/*+disp8   0/rm32/EAX    .           .             .           1/r32/ECX   4/disp8         .                 # copy EAX+4 to ECX
    51/push-ECX
    # . . push outend
    ff          6/subop/push        1/mod/*+disp8   5/rm32/EBP    .           .             .           .           0xc/disp8       .                 # push *(EBP+12)
    # . . push out
    ff          6/subop/push        1/mod/*+disp8   5/rm32/EBP    .           .             .           .           8/disp8         .                 # push *(EBP+8)
    # . . call
    e8/call  _append-4/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               0x10/imm32        # add to ESP
$_append-3:end:
    # . restore registers
    59/pop-to-ECX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

# 4-argument variant of _append
_append-4:  # out : address, outend : address, in : address, inend : address -> num_bytes_appended/EAX
    # . prolog
    55/push-EBP
    89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                 # copy ESP to EBP
    # . save registers
    51/push-ECX
    52/push-EDX
    53/push-EBX
    56/push-ESI
    57/push-EDI
    # EAX/num_bytes_appended = 0
    b8/copy-to-EAX  0/imm32
    # EDI = out
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .             .           7/r32/EDI   8/disp8         .                 # copy *(EBP+8) to EDI
    # EDX = outend
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .             .           2/r32/EDX   0xc/disp8       .                 # copy *(EBP+12) to EDX
    # ESI = in
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .             .           6/r32/ESI   0x10/disp8      .                 # copy *(EBP+16) to ESI
    # ECX = inend
    8b/copy                         1/mod/*+disp8   5/rm32/EBP    .           .             .           1/r32/ECX   0x14/disp8      .                 # copy *(EBP+20) to ECX
$_append-4:loop:
    # if (in >= inend) break
    39/compare                      3/mod/direct    6/rm32/ESI    .           .             .           1/r32/ECX   .               .                 # compare ESI with ECX
    7d/jump-if-greater-or-equal  $_append-4:end/disp8
    # if (out >= outend) abort  # just to catch test failures fast
    39/compare                      3/mod/direct    7/rm32/EDI    .           .             .           2/r32/EDX   .               .                 # compare EDI with EDX
    7d/jump-if-greater-or-equal  $_append-4:abort/disp8
    # *out = *in
    8a/copy-byte                    0/mod/indirect  6/rm32/ESI    .           .             .           3/r32/BL    .               .                 # copy byte at *ESI to BL
    88/copy-byte                    0/mod/indirect  7/rm32/EDI    .           .             .           3/r32/BL    .               .                 # copy byte at BL to *EDI
    # ++num_bytes_appended
    40/increment-EAX
    # ++in
    46/increment-ESI
    # ++out
    47/increment-EDI
    eb/jump  $_append-4:loop/disp8
$_append-4:end:
    # . restore registers
    5f/pop-to-EDI
    5e/pop-to-ESI
    5b/pop-to-EBX
    5a/pop-to-EDX
    59/pop-to-ECX
    # . epilog
    89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                 # copy EBP to ESP
    5d/pop-to-EBP
    c3/return

$_append-4:abort:
    # . _write(2/stderr, error)
    # . . push args
    68/push  "stream overflow"/imm32
    68/push  2/imm32/stderr
    # . . call
    e8/call  _write/disp32
    # . . discard args
    81          0/subop/add         3/mod/direct    4/rm32/ESP    .           .             .           .           .               8/imm32           # add to ESP
    # . syscall(exit, 1)
    bb/copy-to-EBX  1/imm32
    b8/copy-to-EAX  1/imm32/exit
    cd/syscall  0x80/imm8
    # never gets here

# . . vim:nowrap:textwidth=0
