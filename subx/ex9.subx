# Example reading commandline arguments: compute length of first arg.
#
# To run:
#   $ subx translate ex9.subx ex9
#   $ subx run ex9 abc d e f g h
# Expected result:
#   $ echo $?
#   3  # length of 'abc'
#
# At the start of a SubX program:
#   argc: *ESP
#   argv: *(ESP+4)
#   argv[0]: *argv ("ex9" in this case)
#   argv[1]: *(argv+4)
#   ...
# Locals start from ESP-4 downwards.

== 0x08048054  # code segment, after leaving room for ELF header and segment headers
# instruction                     effective address                                                   operand     displacement    immediate
# op          subop               mod             rm32          base        index         scale       r32
# 1-3 bytes   3 bits              2 bits          3 bits        3 bits      3 bits        2 bits      2 bits      0/1/2/4 bytes   0/1/2/4 bytes
  # var s = argv[1] (EBX)
    # var s = argv
  8b/copy                         1/mod/*+disp8   4/rm32/sib    4/base/ESP  4/index/none              3/r32/EBX   4/disp8         .                       # copy *(ESP+4) to EBX
    # s = *(s+4)
  8b/copy                         1/mod/*+disp8   3/rm32/EBX    .           .             .           3/r32/EBX   4/disp8         .                       # copy *(EBX+4) to EBX
  # call ascii_length(EBX)
    # prepare call
  55/push                         .               .             .           .             .           .           .               .                       # push EBP
  89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                       # copy ESP to EBP
    # push args
  53/push                         .               .             .           .             .           .           .               .                       # push EBX
    # call
  e8/call                         .               .             .           .             .           .           ascii_length/disp32
    # discard args
  5a/pop                          .               .             .           .             .           .           .               .                       # pop into EDX
    # clean up after call
  89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                       # copy EBP to ESP
  5d/pop                          .               .             .           .             .           .           .               .                       # pop to EBP

  # exit(EAX)
  89/copy                         3/mod/direct    3/rm32/EBX    .           .             .           0/r32/EAX   .               .                       # copy EAX to EBX
  b8/copy                         .               .             .           .             .           .           .               1/imm32/exit            # copy 1 to EAX
  cd/syscall                      .               .             .           .             .           .           .               0x80/imm8               # int 80h

ascii_length:  # (s)
  # initialize s (EDX)
  8b/copy                         1/mod/*+disp8   4/rm32/sib    4/base/ESP  4/index/none              2/r32/EDX   4/disp8                                 # copy *(ESP+4) to EDX
  # var result = 0 (EAX)
  b8/copy                         .               .             .           .             .           .           .               0/imm32                 # copy 1 to EAX
$al_loop:
  # var c = *s (ECX)
  8a/copy                         0/mod/*         2/rm32/EDX    .           .             .           1/r32/ECX   .               .                       # copy byte at *EDX to lower byte of ECX
  # if c == '\0' break
  81          7/subop/compare     3/mod/direct    1/rm32/ECX    .           .             .           .           .               0/imm32                 # compare ECX with 0
  74/jump-if-zero                 .               .             .           .             .           .           .               $al_ret/disp8           # jump if equal
  # ++s
  81          0/subop/add         3/mod/direct    2/rm32/EDX    .           .             .           .           .               1/imm32                 # add 1 to EDX
  # ++result
  81          0/subop/add         3/mod/direct    0/rm32/EAX    .           .             .           .           .               1/imm32                 # add 1 to EAX
  # loop
  eb/jump                         .               .             .           .             .           .           .               $al_loop/disp8          # jump $al_loop
$al_ret:
  # return (result in EAX)
  c3/return
