## Example reading commandline arguments: compute length of first arg.
#
# To run:
#   $ subx translate ex8.subx ex8
#   $ subx run ex8 abc de fghi
# Expected result:
#   $ echo $?
#   3  # length of 'abc'
#
# At the start of a SubX program:
#   argc: *ESP
#   argv[0]: *(ESP+4)
#   argv[1]: *(ESP+8)
#   ...
# Locals start from ESP-4 downwards.

== code
# instruction                     effective address                                                   operand     displacement    immediate
# op          subop               mod             rm32          base        index         scale       r32
# 1-3 bytes   3 bits              2 bits          3 bits        3 bits      3 bits        2 bits      2 bits      0/1/2/4 bytes   0/1/2/4 bytes
  # var s = argv[1] (EBX)
  8b/copy                         1/mod/*+disp8   4/rm32/sib    4/base/ESP  4/index/none              3/r32/EBX   8/disp8         .                       # copy *(ESP+8) to EBX
  # call ascii_length(EBX)
    # prepare call
  55/push                         .               .             .           .             .           .           .               .                       # push EBP
  89/copy                         3/mod/direct    5/rm32/EBP    .           .             .           4/r32/ESP   .               .                       # copy ESP to EBP
    # push args
  53/push                         .               .             .           .             .           .           .               .                       # push EBX
    # call
  e8/call  ascii_length/disp32
    # discard args
  5a/pop                          .               .             .           .             .           .           .               .                       # pop into EDX
    # clean up after call
  89/copy                         3/mod/direct    4/rm32/ESP    .           .             .           5/r32/EBP   .               .                       # copy EBP to ESP
  5d/pop                          .               .             .           .             .           .           .               .                       # pop to EBP

  # exit(EAX)
  89/copy                         3/mod/direct    3/rm32/EBX    .           .             .           0/r32/EAX   .               .                       # copy EAX to EBX
  b8/copy                         .               .             .           .             .           .           .               1/imm32/exit            # copy 1 to EAX
  cd/syscall  0x80/imm8

ascii_length:  # (s)
  # initialize s (EDX)
  8b/copy                         1/mod/*+disp8   4/rm32/sib    4/base/ESP  4/index/none              2/r32/EDX   4/disp8                                 # copy *(ESP+4) to EDX
  # var result = 0 (EAX)
  b8/copy                         .               .             .           .             .           .           .               0/imm32                 # copy 0 to EAX
$ascii_length_loop:
  # var c = *s (ECX)
  8a/copy                         0/mod/*         2/rm32/EDX    .           .             .           1/r32/ECX   .               .                       # copy byte at *EDX to lower byte of ECX
  # if c == '\0' break
  81          7/subop/compare     3/mod/direct    1/rm32/ECX    .           .             .           .           .               0/imm32                 # compare ECX with 0
  74/jump-if-equal  $ascii_length_ret/disp8
  # ++s
  81          0/subop/add         3/mod/direct    2/rm32/EDX    .           .             .           .           .               1/imm32                 # add 1 to EDX
  # ++result
  81          0/subop/add         3/mod/direct    0/rm32/EAX    .           .             .           .           .               1/imm32                 # add 1 to EAX
  # loop
  eb/jump  $ascii_length_loop/disp8
$ascii_length_ret:
  # return (result in EAX)
  c3/return
