<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 092socket.mu</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="none">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-size: 12pt; font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 12pt; font-size: 1em; }
.muData { color: #ffff00; }
.muControl { color: #c0a020; }
.Delimiter { color: #800080; }
.Comment { color: #9090ff; }
.Constant { color: #00a0a0; }
.Special { color: #c00000; }
.CommentedCode { color: #6c6c6c; }
.muRecipe { color: #ff8700; }
.muScenario { color: #00af00; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment"># Wrappers around socket primitives that are easier to test.</span>
<span class="Comment">#</span>
<span class="Comment"># To test client operations, use `assume-resources` with a filename that</span>
<span class="Comment"># begins with a hostname. (Filenames starting with '/' are assumed to be</span>
<span class="Comment"># local.)</span>
<span class="Comment">#</span>
<span class="Comment"># To test server operations, just run a real client against localhost.</span>

<span class="muScenario">scenario</span> example-server-test [
  <span class="Constant">local-scope</span>
  <span class="Comment"># test server without a fake on a random (real) port</span>
  <span class="Comment"># that way repeatedly running the test will give ports time to timeout and</span>
  <span class="Comment"># close before reusing them</span>
  make-random-nondeterministic
  port:num<span class="Special"> &lt;- </span>random-in-range <span class="Constant">0/real-random-numbers</span>, <span class="Constant">8000</span>, <span class="Constant">8100</span>
  run [
    socket:num<span class="Special"> &lt;- </span>$open-server-socket port
    $print <span class="Constant">[server socket: ]</span>, socket, <span class="Constant">10/newline</span>
    assert socket, <span class="Constant">[ </span>
<span class="Constant">F - example-server-test: $open-server-socket failed]</span>
    $print <span class="Constant">[starting up server routine]</span>, <span class="Constant">10/newline</span>
    handler-routine:number<span class="Special"> &lt;- </span>start-running serve-one-request socket, example-handler
  ]
  $print <span class="Constant">[starting to read from port ]</span>, port, <span class="Constant">10/newline</span>
  source:&amp;:source:char<span class="Special"> &lt;- </span>start-reading-from-network <span class="Constant">0/real-resources</span>, <span class="Constant">[localhost]</span>, <span class="Constant">[/]</span>, port
  response:text<span class="Special"> &lt;- </span>drain source
  <span class="Constant">10</span>:@:char/<span class="Special">raw &lt;- </span>copy *response
  memory-should-contain [
    <span class="Constant">10</span>:array:character<span class="Special"> &lt;- </span><span class="Constant">[abc]</span>
  ]
]
<span class="Comment"># helper just for this scenario</span>
<span class="muRecipe">def</span> example-handler query:text<span class="muRecipe"> -&gt; </span>response:text [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="muControl">reply</span> <span class="Constant">[abc]</span>
]

<span class="CommentedCode">#? scenario example-client-test [</span>
<span class="CommentedCode">#?   local-scope</span>
<span class="CommentedCode">#?   assume-resources [</span>
<span class="CommentedCode">#?     [example.com/] -&gt; [abc]</span>
<span class="CommentedCode">#?   ]</span>
<span class="CommentedCode">#?   run [</span>
<span class="CommentedCode">#?     source:&amp;:source:char &lt;- start-reading-from-network resources, [example.com], [/]</span>
<span class="CommentedCode">#?   ]</span>
<span class="CommentedCode">#?   contents:text &lt;- drain source</span>
<span class="CommentedCode">#?   10:@:char/raw &lt;- copy *contents</span>
<span class="CommentedCode">#?   memory-should-contain [</span>
<span class="CommentedCode">#?     10:address:character &lt;- [abc]</span>
<span class="CommentedCode">#?   ]</span>
<span class="CommentedCode">#? ]</span>

<span class="muData">type</span> request-handler = (recipe text<span class="muRecipe"> -&gt; </span>text)

<span class="muRecipe">def</span> serve-one-request socket:num, request-handler:request-handler [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  session:num<span class="Special"> &lt;- </span>$accept socket
  $print <span class="Constant">[server session socket: ]</span>, session, <span class="Constant">10/newline</span>
  assert session, <span class="Constant">[ </span>
<span class="Constant">F - example-server-test: $accept failed]</span>
  contents:&amp;:source:char, sink:&amp;:sink:char<span class="Special"> &lt;- </span>new-channel <span class="Constant">30</span>
  sink<span class="Special"> &lt;- </span>start-running receive-from-socket session, sink
  query:text<span class="Special"> &lt;- </span>drain contents
  response:text<span class="Special"> &lt;- </span>call request-handler, query
  write-to-socket session, response
  $close-socket session
]

<span class="muRecipe">def</span> start-reading-from-network resources:&amp;:resources, host:text, path:text<span class="muRecipe"> -&gt; </span>contents:&amp;:source:char [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  $print <span class="Constant">[running start-reading-from-network]</span>, <span class="Constant">10/newline</span>
  <span class="Delimiter">{</span>
    port:num, port-found?:boolean<span class="Special"> &lt;- </span><span class="Constant">next-ingredient</span>
    <span class="muControl">break-if</span> port-found?
    port<span class="Special"> &lt;- </span>copy <span class="Constant">80/http-port</span>
  <span class="Delimiter">}</span>
  <span class="Delimiter">{</span>
    <span class="muControl">break-if</span> resources
    <span class="Comment"># real network</span>
    socket:num<span class="Special"> &lt;- </span>$open-client-socket host, port
    $print <span class="Constant">[client socket: ]</span>, socket, <span class="Constant">10/newline</span>
    assert socket, <span class="Constant">[contents]</span>
    req:text<span class="Special"> &lt;- </span>interpolate <span class="Constant">[GET _ HTTP/1.1]</span>, path
    request-socket socket, req
    contents:&amp;:source:char, sink:&amp;:sink:char<span class="Special"> &lt;- </span>new-channel <span class="Constant">10000</span>
    start-running receive-from-socket socket, sink
    <span class="muControl">return</span>
  <span class="Delimiter">}</span>
  <span class="Comment"># fake network</span>
<span class="CommentedCode">#?   i:num &lt;- copy 0</span>
<span class="CommentedCode">#?   data:&amp;:@:resource &lt;- get *fs, data:offset</span>
<span class="CommentedCode">#?   len:num &lt;- length *data</span>
<span class="CommentedCode">#?   {</span>
<span class="CommentedCode">#?     done?:bool &lt;- greater-or-equal i, len</span>
<span class="CommentedCode">#?     break-if done?</span>
<span class="CommentedCode">#?     tmp:resource &lt;- index *data, i</span>
<span class="CommentedCode">#?     i &lt;- add i, 1</span>
<span class="CommentedCode">#?     curr-filename:text &lt;- get tmp, name:offset</span>
<span class="CommentedCode">#?     found?:bool &lt;- equal filename, curr-filename</span>
<span class="CommentedCode">#?     loop-unless found?</span>
<span class="CommentedCode">#?     contents:&amp;:source:char, sink:&amp;:sink:char &lt;- new-channel 30</span>
<span class="CommentedCode">#?     curr-contents:text &lt;- get tmp, contents:offset</span>
<span class="CommentedCode">#?     start-running transmit-from-text curr-contents, sink</span>
<span class="CommentedCode">#?     return</span>
<span class="CommentedCode">#?   }</span>
  <span class="muControl">return</span> <span class="Constant">0/not-found</span>
]

<span class="muRecipe">def</span> request-socket socket:num, s:text<span class="muRecipe"> -&gt; </span>socket:num [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  write-to-socket socket, s
  $write-to-socket socket, <span class="Constant">13/cr</span>
  $write-to-socket socket, <span class="Constant">10/lf</span>
  <span class="Comment"># empty line to delimit request</span>
  $write-to-socket socket, <span class="Constant">13/cr</span>
  $write-to-socket socket, <span class="Constant">10/lf</span>
]

<span class="CommentedCode">#? def start-writing-socket network:&amp;:local-network, port:num -&gt; sink:&amp;:sink:char, routine-id:num [</span>
<span class="CommentedCode">#?   local-scope</span>
<span class="CommentedCode">#?   load-ingredients</span>
<span class="CommentedCode">#?   source:&amp;:source:char, sink:&amp;:sink:char &lt;- new-channel 30</span>
<span class="CommentedCode">#?   {</span>
<span class="CommentedCode">#?     break-if network</span>
<span class="CommentedCode">#?     socket:num &lt;- $open-server-socket port</span>
<span class="CommentedCode">#?     session:num &lt;- $accept socket</span>
<span class="CommentedCode">#?     # TODO Create channel implementation of write-to-socket.</span>
<span class="CommentedCode">#?     return sink, 0/routine-id</span>
<span class="CommentedCode">#?   }</span>
<span class="CommentedCode">#?   # fake network</span>
<span class="CommentedCode">#?   routine-id &lt;- start-running transmit-to-fake-socket network, port, source</span>
<span class="CommentedCode">#? ]</span>

<span class="CommentedCode">#? def transmit-to-fake-socket network:&amp;:local-network, port:num, source:&amp;:source:char -&gt; network:&amp;:local-network, source:&amp;:source:char [</span>
<span class="CommentedCode">#?   local-scope</span>
<span class="CommentedCode">#?   load-ingredients</span>
<span class="CommentedCode">#?   # compute new port connection contents</span>
<span class="CommentedCode">#?   buf:&amp;:buffer &lt;- new-buffer 30</span>
<span class="CommentedCode">#?   {</span>
<span class="CommentedCode">#?     c:char, done?:bool, source &lt;- read source</span>
<span class="CommentedCode">#?     break-unless c</span>
<span class="CommentedCode">#?     buf &lt;- append buf, c</span>
<span class="CommentedCode">#?     break-if done?</span>
<span class="CommentedCode">#?     loop</span>
<span class="CommentedCode">#?   }</span>
<span class="CommentedCode">#?   contents:text &lt;- buffer-to-array buf</span>
<span class="CommentedCode">#?   new-port-connection:&amp;:port-connection &lt;- new-port-connection port, contents</span>
<span class="CommentedCode">#?   # Got the contents of the channel, time to write to fake port.</span>
<span class="CommentedCode">#?   i:num &lt;- copy 0</span>
<span class="CommentedCode">#?   port-connections:&amp;:@:port-connection &lt;- get *network, data:offset</span>
<span class="CommentedCode">#?   len:num &lt;- length *port-connections</span>
<span class="CommentedCode">#?   {</span>
<span class="CommentedCode">#?     done?:bool &lt;- greater-or-equal i, len</span>
<span class="CommentedCode">#?     break-if done?</span>
<span class="CommentedCode">#?     current:port-connection &lt;- index *port-connections, i</span>
<span class="CommentedCode">#?     current-port:num &lt;- get current, port:offset</span>
<span class="CommentedCode">#?     ports-match?:bool &lt;- equal current-port, port</span>
<span class="CommentedCode">#?     i &lt;- add i, 1</span>
<span class="CommentedCode">#?     loop-unless ports-match?</span>
<span class="CommentedCode">#?     # Found an existing connection on this port, overwrite.</span>
<span class="CommentedCode">#?     put-index *port-connections, i, *new-port-connection</span>
<span class="CommentedCode">#?     reply</span>
<span class="CommentedCode">#?   }</span>
<span class="CommentedCode">#?   # Couldn't find an existing connection on this port, initialize a new one.</span>
<span class="CommentedCode">#?   new-len:num &lt;- add len, 1</span>
<span class="CommentedCode">#?   new-port-connections:&amp;:@:port-connection &lt;- new port-connection:type, new-len</span>
<span class="CommentedCode">#?   put *network, data:offset, new-port-connections</span>
<span class="CommentedCode">#?   i:num &lt;- copy 0</span>
<span class="CommentedCode">#?   {</span>
<span class="CommentedCode">#?     done?:bool &lt;- greater-or-equal i, len</span>
<span class="CommentedCode">#?     break-if done?</span>
<span class="CommentedCode">#?     tmp:port-connection &lt;- index *port-connections, i</span>
<span class="CommentedCode">#?     put-index *new-port-connections, i, tmp</span>
<span class="CommentedCode">#?   }</span>
<span class="CommentedCode">#?   put-index *new-port-connections, len, *new-port-connection</span>
<span class="CommentedCode">#? ]</span>

<span class="muRecipe">def</span> receive-from-socket socket:num, sink:&amp;:sink:char<span class="muRecipe"> -&gt; </span>sink:&amp;:sink:char [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  <span class="Delimiter">{</span>
    $print <span class="Constant">[read-from-socket ]</span>, socket, <span class="Constant">10/newline</span>
    req:text, eof?:bool<span class="Special"> &lt;- </span>$read-from-socket socket, <span class="Constant">4096/bytes</span>
    <span class="muControl">loop-unless</span> req
    bytes-read:num<span class="Special"> &lt;- </span>length *req
    i:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
    <span class="Delimiter">{</span>
      done?:bool<span class="Special"> &lt;- </span>greater-or-equal i, bytes-read
      <span class="muControl">break-if</span> done?
      c:char<span class="Special"> &lt;- </span>index *req, i  <span class="Comment"># todo: unicode</span>
      sink<span class="Special"> &lt;- </span>write sink, c
      i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
      <span class="muControl">loop</span>
    <span class="Delimiter">}</span>
    <span class="muControl">loop-unless</span> eof?
  <span class="Delimiter">}</span>
  sink<span class="Special"> &lt;- </span>close sink
]

<span class="muRecipe">def</span> write-to-socket socket:num, s:text [
  <span class="Constant">local-scope</span>
  <span class="Constant">load-ingredients</span>
  len:num<span class="Special"> &lt;- </span>length *s
  i:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Delimiter">{</span>
    done?:bool<span class="Special"> &lt;- </span>greater-or-equal i, len
    <span class="muControl">break-if</span> done?
    c:char<span class="Special"> &lt;- </span>index *s, i
    $write-to-socket socket, c
    i<span class="Special"> &lt;- </span>add i, <span class="Constant">1</span>
    <span class="muControl">loop</span>
  <span class="Delimiter">}</span>
]
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
