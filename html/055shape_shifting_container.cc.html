<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 055shape_shifting_container.cc</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-size: 12pt; font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 12pt; font-size: 1em; }
.Constant { color: #00a0a0; }
.Special { color: #c00000; }
.traceContains { color: #008000; }
.cSpecial { color: #008000; }
.Comment { color: #9090ff; }
.Delimiter { color: #800080; }
.SalientComment { color: #00ffff; }
.Identifier { color: #fcb165; }
.Normal { color: #eeeeee; background-color: #080808; padding-bottom: 1px; }
.CommentedCode { color: #6c6c6c; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="SalientComment">//:: Container definitions can contain 'type ingredients'</span>

<span class="Comment">//: pre-requisite: extend our notion of containers to not necessarily be</span>
<span class="Comment">//: atomic types</span>
<span class="Delimiter">:(before &quot;End is_mu_container(type) Special-cases&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span>
  <span class="Identifier">return</span> is_mu_container<span class="Delimiter">(</span>root_type<span class="Delimiter">(</span>type<span class="Delimiter">));</span>
<span class="Delimiter">:(before &quot;End is_mu_exclusive_container(type) Special-cases&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span>
  <span class="Identifier">return</span> is_mu_exclusive_container<span class="Delimiter">(</span>root_type<span class="Delimiter">(</span>type<span class="Delimiter">));</span>
<span class="Comment">// a few calls to root_type() without the assertion (for better error handling)</span>
<span class="Delimiter">:(after &quot;Update GET base_type in Check&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!base_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span> base_type = base_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">;</span>
<span class="Delimiter">:(after &quot;Update GET base_type in Run&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!base_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span> base_type = base_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">;</span>
<span class="Delimiter">:(after &quot;Update PUT base_type in Check&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!base_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span> base_type = base_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">;</span>
<span class="Delimiter">:(after &quot;Update PUT base_type in Run&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!base_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span> base_type = base_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">;</span>
<span class="Delimiter">:(after &quot;Update MAYBE_CONVERT base_type in Check&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!base_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span> base_type = base_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">;</span>

<span class="Delimiter">:(scenario size_of_shape_shifting_container)</span>
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:number<span class="Special"> &lt;- </span>merge <span class="Constant">12</span><span class="Delimiter">,</span> <span class="Constant">13</span>
  <span class="Constant">3</span>:foo:point<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span><span class="Delimiter">,</span> <span class="Constant">16</span>
]
<span class="traceContains">+mem: storing 12 in location 1</span>
<span class="traceContains">+mem: storing 13 in location 2</span>
<span class="traceContains">+mem: storing 14 in location 3</span>
<span class="traceContains">+mem: storing 15 in location 4</span>
<span class="traceContains">+mem: storing 16 in location 5</span>

<span class="Delimiter">:(scenario size_of_shape_shifting_container_2)</span>
<span class="Comment"># multiple type ingredients</span>
container foo:_a:_b [
  <span class="Normal">x</span>:_a
  <span class="Normal">y</span>:_b
]
def main [
  <span class="Constant">1</span>:foo:number:boolean<span class="Special"> &lt;- </span>merge <span class="Constant">34</span><span class="Delimiter">,</span> <span class="Constant">1</span>/<span class="Constant">true</span>
]
$error: <span class="Constant">0</span>

<span class="Delimiter">:(scenario size_of_shape_shifting_container_3)</span>
container foo:_a:_b [
  <span class="Normal">x</span>:_a
  <span class="Normal">y</span>:_b
]
def main [
  <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span><span class="Normal">new</span> [abc]
  <span class="Comment"># compound types for type ingredients</span>
  <span class="Delimiter">{</span><span class="Constant">2</span>: <span class="Delimiter">(</span>foo number <span class="Delimiter">(</span>address array character<span class="Delimiter">))}</span><span class="Special"> &lt;- </span>merge <span class="Constant">34</span>/x<span class="Delimiter">,</span> <span class="Constant">1</span>:address:array:character/y
]
$error: <span class="Constant">0</span>

<span class="Delimiter">:(scenario size_of_shape_shifting_container_4)</span>
container foo:_a:_b [
  <span class="Normal">x</span>:_a
  <span class="Normal">y</span>:_b
]
container bar:_a:_b [
  <span class="Comment"># dilated element</span>
  <span class="Delimiter">{</span>data: <span class="Delimiter">(</span>foo _a <span class="Delimiter">(</span>address _b<span class="Delimiter">))}</span>
]
def main [
  <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span><span class="Normal">new</span> [abc]
  <span class="Constant">2</span>:bar:number:array:character<span class="Special"> &lt;- </span>merge <span class="Constant">34</span>/x<span class="Delimiter">,</span> <span class="Constant">1</span>:address:array:character/y
]
$error: <span class="Constant">0</span>

<span class="Delimiter">:(scenario shape_shifting_container_extend)</span>
container foo:_a [
  <span class="Normal">x</span>:_a
]
container foo:_a [
  <span class="Normal">y</span>:_a
]
$error: <span class="Constant">0</span>

<span class="Delimiter">:(scenario shape_shifting_container_extend_error)</span>
<span class="Special">% Hide_errors = true;</span>
container foo:_a [
  <span class="Normal">x</span>:_a
]
container foo:_b [
  <span class="Normal">y</span>:_b
]
<span class="traceContains">+error: headers of container 'foo' must use identical type ingredients</span>

<span class="Delimiter">:(scenario type_ingredient_must_start_with_underscore)</span>
<span class="Special">% Hide_errors = true;</span>
container foo:t [
  <span class="Normal">x</span>:number
]
<span class="traceContains">+error: foo: type ingredient 't' must begin with an underscore</span>

<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
<span class="Comment">// We'll use large type ordinals to mean &quot;the following type of the variable&quot;.</span>
<span class="Comment">// For example, if we have a generic type called foo:_elem, the type</span>
<span class="Comment">// ingredient _elem in foo's type_info will have value START_TYPE_INGREDIENTS,</span>
<span class="Comment">// and we'll handle it by looking in the current reagent for the next type</span>
<span class="Comment">// that appears after foo.</span>
<span class="Normal">extern</span> <span class="Normal">const</span> <span class="Normal">int</span> START_TYPE_INGREDIENTS = <span class="Constant">2000</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Commandline Parsing&quot;)</span>  <span class="Comment">// after loading .mu files</span>
assert<span class="Delimiter">(</span>Next_type_ordinal &lt; START_TYPE_INGREDIENTS<span class="Delimiter">);</span>

<span class="Delimiter">:(before &quot;End type_info Fields&quot;)</span>
map&lt;string<span class="Delimiter">,</span> type_ordinal&gt; type_ingredient_names<span class="Delimiter">;</span>

<span class="Comment">//: Suppress unknown type checks in shape-shifting containers.</span>

<span class="Delimiter">:(before &quot;Check Container Field Types(info)&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>!info<span class="Delimiter">.</span>type_ingredient_names<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>

<span class="Delimiter">:(before &quot;End container Name Refinements&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>name<span class="Delimiter">.</span>find<span class="Delimiter">(</span><span class="Constant">':'</span><span class="Delimiter">)</span> != string::npos<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  trace<span class="Delimiter">(</span><span class="Constant">9999</span><span class="Delimiter">,</span> <span class="Constant">&quot;parse&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;container has type ingredients; parsing&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!read_type_ingredients<span class="Delimiter">(</span>name<span class="Delimiter">,</span> command<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    <span class="Comment">// error; skip rest of the container definition and continue</span>
    slurp_balanced_bracket<span class="Delimiter">(</span>in<span class="Delimiter">);</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
<span class="Normal">bool</span> read_type_ingredients<span class="Delimiter">(</span>string&amp; name<span class="Delimiter">,</span> <span class="Normal">const</span> string&amp; command<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  string save_name = name<span class="Delimiter">;</span>
  istringstream in<span class="Delimiter">(</span>save_name<span class="Delimiter">);</span>
  name = slurp_until<span class="Delimiter">(</span>in<span class="Delimiter">,</span> <span class="Constant">':'</span><span class="Delimiter">);</span>
  map&lt;string<span class="Delimiter">,</span> type_ordinal&gt; type_ingredient_names<span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!slurp_type_ingredients<span class="Delimiter">(</span>in<span class="Delimiter">,</span> type_ingredient_names<span class="Delimiter">,</span> name<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> name<span class="Delimiter">)</span>
      &amp;&amp; contains_key<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> name<span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    <span class="Normal">const</span> type_info&amp; previous_info = get<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> name<span class="Delimiter">));</span>
    <span class="Comment">// we've already seen this container; make sure type ingredients match</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!type_ingredients_match<span class="Delimiter">(</span>type_ingredient_names<span class="Delimiter">,</span> previous_info<span class="Delimiter">.</span>type_ingredient_names<span class="Delimiter">))</span> <span class="Delimiter">{</span>
      raise &lt;&lt; <span class="Constant">&quot;headers of &quot;</span> &lt;&lt; command &lt;&lt; <span class="Constant">&quot; '&quot;</span> &lt;&lt; name &lt;&lt; <span class="Constant">&quot;' must use identical type ingredients</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
      <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
    <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// we haven't seen this container before</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!contains_key<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> name<span class="Delimiter">)</span> || get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> name<span class="Delimiter">)</span> == <span class="Constant">0</span><span class="Delimiter">)</span>
    put<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> name<span class="Delimiter">,</span> Next_type_ordinal++<span class="Delimiter">);</span>
  type_info&amp; info = get_or_insert<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> get<span class="Delimiter">(</span>Type_ordinal<span class="Delimiter">,</span> name<span class="Delimiter">));</span>
  info<span class="Delimiter">.</span>type_ingredient_names<span class="Delimiter">.</span>swap<span class="Delimiter">(</span>type_ingredient_names<span class="Delimiter">);</span>
  <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> slurp_type_ingredients<span class="Delimiter">(</span>istream&amp; in<span class="Delimiter">,</span> map&lt;string<span class="Delimiter">,</span> type_ordinal&gt;&amp; out<span class="Delimiter">,</span> <span class="Normal">const</span> string&amp; container_name<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">int</span> next_type_ordinal = START_TYPE_INGREDIENTS<span class="Delimiter">;</span>
  <span class="Normal">while</span> <span class="Delimiter">(</span>has_data<span class="Delimiter">(</span>in<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    string curr = slurp_until<span class="Delimiter">(</span>in<span class="Delimiter">,</span> <span class="Constant">':'</span><span class="Delimiter">);</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>curr<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Delimiter">{</span>
      raise &lt;&lt; container_name &lt;&lt; <span class="Constant">&quot;: empty type ingredients not permitted</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
      <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!starts_with<span class="Delimiter">(</span>curr<span class="Delimiter">,</span> <span class="Constant">&quot;_&quot;</span><span class="Delimiter">))</span> <span class="Delimiter">{</span>
      raise &lt;&lt; container_name &lt;&lt; <span class="Constant">&quot;: type ingredient '&quot;</span> &lt;&lt; curr &lt;&lt; <span class="Constant">&quot;' must begin with an underscore</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
      <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>out<span class="Delimiter">.</span>find<span class="Delimiter">(</span>curr<span class="Delimiter">)</span> != out<span class="Delimiter">.</span>end<span class="Delimiter">())</span> <span class="Delimiter">{</span>
      raise &lt;&lt; container_name &lt;&lt; <span class="Constant">&quot;: can't repeat type ingredient name'&quot;</span> &lt;&lt; curr &lt;&lt; <span class="Constant">&quot;' in a single container definition</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
      <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
    put<span class="Delimiter">(</span>out<span class="Delimiter">,</span> curr<span class="Delimiter">,</span> next_type_ordinal++<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> type_ingredients_match<span class="Delimiter">(</span><span class="Normal">const</span> map&lt;string<span class="Delimiter">,</span> type_ordinal&gt;&amp; a<span class="Delimiter">,</span> <span class="Normal">const</span> map&lt;string<span class="Delimiter">,</span> type_ordinal&gt;&amp; b<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>a<span class="Delimiter">)</span> != SIZE<span class="Delimiter">(</span>b<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span>map&lt;string<span class="Delimiter">,</span> type_ordinal&gt;::const_iterator p = a<span class="Delimiter">.</span>begin<span class="Delimiter">();</span> p != a<span class="Delimiter">.</span>end<span class="Delimiter">();</span> ++p<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!contains_key<span class="Delimiter">(</span>b<span class="Delimiter">,</span> p<span class="Delimiter">-&gt;</span>first<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>p<span class="Delimiter">-&gt;</span>second != get<span class="Delimiter">(</span>b<span class="Delimiter">,</span> p<span class="Delimiter">-&gt;</span>first<span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End insert_container Special-cases&quot;)</span>
<span class="Comment">// check for use of type ingredients</span>
<span class="Normal">else</span> <span class="Normal">if</span> <span class="Delimiter">(</span>is_type_ingredient_name<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">))</span> <span class="Delimiter">{</span>
  type<span class="Delimiter">-&gt;</span>value = get<span class="Delimiter">(</span>info<span class="Delimiter">.</span>type_ingredient_names<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">);</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(code)</span>
<span class="Normal">bool</span> is_type_ingredient_name<span class="Delimiter">(</span><span class="Normal">const</span> string&amp; type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Identifier">return</span> starts_with<span class="Delimiter">(</span>type<span class="Delimiter">,</span> <span class="Constant">&quot;_&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Container Type Checks&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>value &gt;= START_TYPE_INGREDIENTS
    &amp;&amp; <span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>value - START_TYPE_INGREDIENTS<span class="Delimiter">)</span> &lt; SIZE<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>value<span class="Delimiter">).</span>type_ingredient_names<span class="Delimiter">))</span>
  <span class="Identifier">return</span><span class="Delimiter">;</span>

<span class="Delimiter">:(scenario size_of_shape_shifting_exclusive_container)</span>
exclusive-container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:number<span class="Special"> &lt;- </span>merge <span class="Constant">0</span>/x<span class="Delimiter">,</span> <span class="Constant">34</span>
  <span class="Constant">3</span>:foo:point<span class="Special"> &lt;- </span>merge <span class="Constant">0</span>/x<span class="Delimiter">,</span> <span class="Constant">15</span><span class="Delimiter">,</span> <span class="Constant">16</span>
  <span class="Constant">6</span>:foo:point<span class="Special"> &lt;- </span>merge <span class="Constant">1</span>/y<span class="Delimiter">,</span> <span class="Constant">23</span>
]
<span class="traceContains">+run: {1: (&quot;foo&quot; &quot;number&quot;)} &lt;- merge {0: &quot;literal&quot;, &quot;x&quot;: ()}, {34: &quot;literal&quot;}</span>
<span class="traceContains">+mem: storing 0 in location 1</span>
<span class="traceContains">+mem: storing 34 in location 2</span>
<span class="traceContains">+run: {3: (&quot;foo&quot; &quot;point&quot;)} &lt;- merge {0: &quot;literal&quot;, &quot;x&quot;: ()}, {15: &quot;literal&quot;}, {16: &quot;literal&quot;}</span>
<span class="traceContains">+mem: storing 0 in location 3</span>
<span class="traceContains">+mem: storing 15 in location 4</span>
<span class="traceContains">+mem: storing 16 in location 5</span>
<span class="traceContains">+run: {6: (&quot;foo&quot; &quot;point&quot;)} &lt;- merge {1: &quot;literal&quot;, &quot;y&quot;: ()}, {23: &quot;literal&quot;}</span>
<span class="traceContains">+mem: storing 1 in location 6</span>
<span class="traceContains">+mem: storing 23 in location 7</span>
<span class="traceContains">+run: reply</span>
<span class="Comment"># no other stores</span>
<span class="Special">% CHECK_EQ(trace_count_prefix(&quot;mem&quot;, &quot;storing&quot;), 7);</span>

<span class="Delimiter">:(scenario get_on_shape_shifting_container)</span>
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:point<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span><span class="Delimiter">,</span> <span class="Constant">16</span>
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>get <span class="Constant">1</span>:foo:point<span class="Delimiter">,</span> y:offset
]
<span class="traceContains">+mem: storing 16 in location 2</span>

<span class="Delimiter">:(scenario get_on_shape_shifting_container_2)</span>
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:point<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span><span class="Delimiter">,</span> <span class="Constant">16</span>
  <span class="Constant">2</span>:point<span class="Special"> &lt;- </span>get <span class="Constant">1</span>:foo:point<span class="Delimiter">,</span> x:offset
]
<span class="traceContains">+mem: storing 14 in location 2</span>
<span class="traceContains">+mem: storing 15 in location 3</span>

<span class="Delimiter">:(scenario get_on_shape_shifting_container_3)</span>
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:address:point<span class="Special"> &lt;- </span>merge <span class="Constant">34</span>/unsafe<span class="Delimiter">,</span> <span class="Constant">48</span>
  <span class="Constant">3</span>:address:point<span class="Special"> &lt;- </span>get <span class="Constant">1</span>:foo:address:point<span class="Delimiter">,</span> x:offset
]
<span class="traceContains">+mem: storing 34 in location 3</span>

<span class="Delimiter">:(scenario get_on_shape_shifting_container_inside_container)</span>
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
container bar [
  <span class="Normal">x</span>:foo:point
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:bar<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span><span class="Delimiter">,</span> <span class="Constant">16</span><span class="Delimiter">,</span> <span class="Constant">17</span>
  <span class="Constant">2</span>:number<span class="Special"> &lt;- </span>get <span class="Constant">1</span>:bar<span class="Delimiter">,</span> <span class="Constant">1</span>:offset
]
<span class="traceContains">+mem: storing 17 in location 2</span>

<span class="Delimiter">:(scenario get_on_complex_shape_shifting_container)</span>
container foo:_a:_b [
  <span class="Normal">x</span>:_a
  <span class="Normal">y</span>:_b
]
def main [
  <span class="Constant">1</span>:address:array:character<span class="Special"> &lt;- </span><span class="Normal">new</span> [abc]
  <span class="Delimiter">{</span><span class="Constant">2</span>: <span class="Delimiter">(</span>foo number <span class="Delimiter">(</span>address array character<span class="Delimiter">))}</span><span class="Special"> &lt;- </span>merge <span class="Constant">34</span>/x<span class="Delimiter">,</span> <span class="Constant">1</span>:address:array:character/y
  <span class="Constant">3</span>:address:array:character<span class="Special"> &lt;- </span>get <span class="Delimiter">{</span><span class="Constant">2</span>: <span class="Delimiter">(</span>foo number <span class="Delimiter">(</span>address array character<span class="Delimiter">))},</span> y:offset
  <span class="Constant">4</span>:boolean<span class="Special"> &lt;- </span>equal <span class="Constant">1</span>:address:array:character<span class="Delimiter">,</span> <span class="Constant">3</span>:address:array:character
]
<span class="traceContains">+mem: storing 1 in location 4</span>

<span class="Delimiter">:(before &quot;End element_type Special-cases&quot;)</span>
replace_type_ingredients<span class="Delimiter">(</span>element<span class="Delimiter">,</span> type<span class="Delimiter">,</span> info<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;Compute Container Size(element, full_type)&quot;)</span>
replace_type_ingredients<span class="Delimiter">(</span>element<span class="Delimiter">,</span> full_type<span class="Delimiter">,</span> container_info<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;Compute Exclusive Container Size(element, full_type)&quot;)</span>
replace_type_ingredients<span class="Delimiter">(</span>element<span class="Delimiter">,</span> full_type<span class="Delimiter">,</span> exclusive_container_info<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;Compute Container Address Offset(element)&quot;)</span>
replace_type_ingredients<span class="Delimiter">(</span>element<span class="Delimiter">,</span> type<span class="Delimiter">,</span> info<span class="Delimiter">);</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>contains_type_ingredient<span class="Delimiter">(</span>element<span class="Delimiter">))</span> <span class="Identifier">return</span><span class="Delimiter">;</span>  <span class="Comment">// error raised elsewhere</span>

<span class="Delimiter">:(code)</span>
<span class="Normal">void</span> replace_type_ingredients<span class="Delimiter">(</span>reagent&amp; element<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree* caller_type<span class="Delimiter">,</span> <span class="Normal">const</span> type_info&amp; info<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>contains_type_ingredient<span class="Delimiter">(</span>element<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>!caller_type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span>
      raise &lt;&lt; <span class="Constant">&quot;illegal type &quot;</span> &lt;&lt; names_to_string<span class="Delimiter">(</span>caller_type<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot; seems to be missing a type ingredient or three</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    replace_type_ingredients<span class="Delimiter">(</span>element<span class="Delimiter">.</span>type<span class="Delimiter">,</span> caller_type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> info<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(after &quot;Compute size_of Container&quot;)</span>
assert<span class="Delimiter">(</span>!contains_type_ingredient<span class="Delimiter">(</span>type<span class="Delimiter">));</span>
<span class="Delimiter">:(after &quot;Compute size_of Exclusive Container&quot;)</span>
assert<span class="Delimiter">(</span>!contains_type_ingredient<span class="Delimiter">(</span>type<span class="Delimiter">));</span>

<span class="Delimiter">:(code)</span>
<span class="Normal">bool</span> contains_type_ingredient<span class="Delimiter">(</span><span class="Normal">const</span> reagent&amp; x<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Identifier">return</span> contains_type_ingredient<span class="Delimiter">(</span>x<span class="Delimiter">.</span>type<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> contains_type_ingredient<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* type<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span> <span class="Identifier">return</span> type<span class="Delimiter">-&gt;</span>value &gt;= START_TYPE_INGREDIENTS<span class="Delimiter">;</span>
  <span class="Identifier">return</span> contains_type_ingredient<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">)</span> || contains_type_ingredient<span class="Delimiter">(</span>type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Comment">// replace all type_ingredients in element_type with corresponding elements of callsite_type</span>
<span class="Normal">void</span> replace_type_ingredients<span class="Delimiter">(</span>type_tree* element_type<span class="Delimiter">,</span> <span class="Normal">const</span> type_tree* callsite_type<span class="Delimiter">,</span> <span class="Normal">const</span> type_info&amp; container_info<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!callsite_type<span class="Delimiter">)</span> <span class="Identifier">return</span><span class="Delimiter">;</span>  <span class="Comment">// error but it's already been raised above</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!element_type<span class="Delimiter">)</span> <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!element_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    replace_type_ingredients<span class="Delimiter">(</span>element_type<span class="Delimiter">-&gt;</span>left<span class="Delimiter">,</span> callsite_type<span class="Delimiter">,</span> container_info<span class="Delimiter">);</span>
    replace_type_ingredients<span class="Delimiter">(</span>element_type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> callsite_type<span class="Delimiter">,</span> container_info<span class="Delimiter">);</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>element_type<span class="Delimiter">-&gt;</span>value &lt; START_TYPE_INGREDIENTS<span class="Delimiter">)</span> <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Normal">const</span> <span class="Normal">int</span> type_ingredient_index = element_type<span class="Delimiter">-&gt;</span>value-START_TYPE_INGREDIENTS<span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!has_nth_type<span class="Delimiter">(</span>callsite_type<span class="Delimiter">,</span> type_ingredient_index<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; <span class="Constant">&quot;illegal type &quot;</span> &lt;&lt; names_to_string<span class="Delimiter">(</span>callsite_type<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot; seems to be missing a type ingredient or three</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">return</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  *element_type = *nth_type_ingredient<span class="Delimiter">(</span>callsite_type<span class="Delimiter">,</span> type_ingredient_index<span class="Delimiter">,</span> container_info<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">const</span> type_tree* nth_type_ingredient<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* callsite_type<span class="Delimiter">,</span> <span class="Normal">int</span> type_ingredient_index<span class="Delimiter">,</span> <span class="Normal">const</span> type_info&amp; container_info<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">bool</span> <span class="Normal">final</span> = final_type_ingredient<span class="Delimiter">(</span>type_ingredient_index<span class="Delimiter">,</span> container_info<span class="Delimiter">);</span>
  <span class="Normal">const</span> type_tree* curr = callsite_type<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span> i &lt; type_ingredient_index<span class="Delimiter">;</span> ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    assert<span class="Delimiter">(</span>curr<span class="Delimiter">);</span>
    assert<span class="Delimiter">(</span>!curr<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">);</span>
<span class="CommentedCode">//?     cerr &lt;&lt; &quot;type ingredient &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; to_string(curr-&gt;left) &lt;&lt; '\n';</span>
    curr = curr<span class="Delimiter">-&gt;</span>right<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  assert<span class="Delimiter">(</span>curr<span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>curr<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">)</span> <span class="Identifier">return</span> curr<span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!<span class="Normal">final</span><span class="Delimiter">)</span> <span class="Identifier">return</span> curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!curr<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span> <span class="Identifier">return</span> curr<span class="Delimiter">-&gt;</span>left<span class="Delimiter">;</span>
  <span class="Identifier">return</span> curr<span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> final_type_ingredient<span class="Delimiter">(</span><span class="Normal">int</span> type_ingredient_index<span class="Delimiter">,</span> <span class="Normal">const</span> type_info&amp; container_info<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span>map&lt;string<span class="Delimiter">,</span> type_ordinal&gt;::const_iterator p = container_info<span class="Delimiter">.</span>type_ingredient_names<span class="Delimiter">.</span>begin<span class="Delimiter">();</span>
       p != container_info<span class="Delimiter">.</span>type_ingredient_names<span class="Delimiter">.</span>end<span class="Delimiter">();</span>
       ++p<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>p<span class="Delimiter">-&gt;</span>second &gt; START_TYPE_INGREDIENTS+type_ingredient_index<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Unit Tests&quot;)</span>
<span class="Normal">void</span> test_replace_type_ingredients_entire<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:_elem</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;x:foo:point&quot;</span><span class="Delimiter">);</span>
  reagent element = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element<span class="Delimiter">),</span> <span class="Constant">&quot;{x: </span><span class="cSpecial">\&quot;</span><span class="Constant">point</span><span class="cSpecial">\&quot;</span><span class="Constant">}&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_replace_type_ingredients_tail<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:_elem</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;container bar:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:foo:_elem</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;x:bar:point&quot;</span><span class="Delimiter">);</span>
  reagent element = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element<span class="Delimiter">),</span> <span class="Constant">&quot;{x: (</span><span class="cSpecial">\&quot;</span><span class="Constant">foo</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">point</span><span class="cSpecial">\&quot;</span><span class="Constant">)}&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_replace_type_ingredients_head_tail_multiple<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:_elem</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;container bar:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:foo:_elem</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;x:bar:address:array:character&quot;</span><span class="Delimiter">);</span>
  reagent element = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element<span class="Delimiter">),</span> <span class="Constant">&quot;{x: (</span><span class="cSpecial">\&quot;</span><span class="Constant">foo</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">address</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">array</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">character</span><span class="cSpecial">\&quot;</span><span class="Constant">)}&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_replace_type_ingredients_head_middle<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:_elem</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;container bar:_elem [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:foo:_elem:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;x:bar:address&quot;</span><span class="Delimiter">);</span>
  reagent element = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element<span class="Delimiter">),</span> <span class="Constant">&quot;{x: (</span><span class="cSpecial">\&quot;</span><span class="Constant">foo</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">address</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">number</span><span class="cSpecial">\&quot;</span><span class="Constant">)}&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_replace_last_type_ingredient_with_multiple<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_a:_b [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:_a</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:_b</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;{f: (foo number (address array character))}&quot;</span><span class="Delimiter">);</span>
  reagent element1 = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element1<span class="Delimiter">),</span> <span class="Constant">&quot;{x: </span><span class="cSpecial">\&quot;</span><span class="Constant">number</span><span class="cSpecial">\&quot;</span><span class="Constant">}&quot;</span><span class="Delimiter">);</span>
  reagent element2 = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">1</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element2<span class="Delimiter">),</span> <span class="Constant">&quot;{y: (</span><span class="cSpecial">\&quot;</span><span class="Constant">address</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">array</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">character</span><span class="cSpecial">\&quot;</span><span class="Constant">)}&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_replace_middle_type_ingredient_with_multiple<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_a:_b:_c [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:_a</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:_b</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  z:_c</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;{f: (foo number (address array character) boolean)}&quot;</span><span class="Delimiter">);</span>
  reagent element1 = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element1<span class="Delimiter">),</span> <span class="Constant">&quot;{x: </span><span class="cSpecial">\&quot;</span><span class="Constant">number</span><span class="cSpecial">\&quot;</span><span class="Constant">}&quot;</span><span class="Delimiter">);</span>
  reagent element2 = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">1</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element2<span class="Delimiter">),</span> <span class="Constant">&quot;{y: (</span><span class="cSpecial">\&quot;</span><span class="Constant">address</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">array</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">character</span><span class="cSpecial">\&quot;</span><span class="Constant">)}&quot;</span><span class="Delimiter">);</span>
  reagent element3 = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">2</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element3<span class="Delimiter">),</span> <span class="Constant">&quot;{z: </span><span class="cSpecial">\&quot;</span><span class="Constant">boolean</span><span class="cSpecial">\&quot;</span><span class="Constant">}&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_replace_middle_type_ingredient_with_multiple2<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_key:_value [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  key:_key</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  value:_value</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;{f: (foo (address array character) number)}&quot;</span><span class="Delimiter">);</span>
  reagent element = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element<span class="Delimiter">),</span> <span class="Constant">&quot;{key: (</span><span class="cSpecial">\&quot;</span><span class="Constant">address</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">array</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">character</span><span class="cSpecial">\&quot;</span><span class="Constant">)}&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_replace_middle_type_ingredient_with_multiple3<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo_table:_key:_value [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  data:address:array:foo_table_row:_key:_value</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;container foo_table_row:_key:_value [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  key:_key</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  value:_value</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent callsite<span class="Delimiter">(</span><span class="Constant">&quot;{f: (foo_table (address array character) number)}&quot;</span><span class="Delimiter">);</span>
  reagent element = element_type<span class="Delimiter">(</span>callsite<span class="Delimiter">.</span>type<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>to_string<span class="Delimiter">(</span>element<span class="Delimiter">),</span> <span class="Constant">&quot;{data: (</span><span class="cSpecial">\&quot;</span><span class="Constant">address</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">array</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">foo_table_row</span><span class="cSpecial">\&quot;</span><span class="Constant"> (</span><span class="cSpecial">\&quot;</span><span class="Constant">address</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">array</span><span class="cSpecial">\&quot;</span><span class="Constant"> </span><span class="cSpecial">\&quot;</span><span class="Constant">character</span><span class="cSpecial">\&quot;</span><span class="Constant">) </span><span class="cSpecial">\&quot;</span><span class="Constant">number</span><span class="cSpecial">\&quot;</span><span class="Constant">)}&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
<span class="Normal">bool</span> has_nth_type<span class="Delimiter">(</span><span class="Normal">const</span> type_tree* base<span class="Delimiter">,</span> <span class="Normal">int</span> n<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  assert<span class="Delimiter">(</span>n &gt;= <span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!base<span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>n == <span class="Constant">0</span><span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Identifier">return</span> has_nth_type<span class="Delimiter">(</span>base<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> n-<span class="Constant">1</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario get_on_shape_shifting_container_error)</span>
<span class="Special">% Hide_errors = true;</span>
container foo:_t [
  <span class="Normal">x</span>:_t
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">10</span>:foo:point<span class="Special"> &lt;- </span>merge <span class="Constant">14</span><span class="Delimiter">,</span> <span class="Constant">15</span><span class="Delimiter">,</span> <span class="Constant">16</span>
  <span class="Constant">1</span>:number<span class="Special"> &lt;- </span>get <span class="Constant">10</span>:foo<span class="Delimiter">,</span> <span class="Constant">1</span>:offset
]
<span class="traceContains">+error: illegal type &quot;foo&quot; seems to be missing a type ingredient or three</span>

<span class="SalientComment">//:: fix up previous layers</span>

<span class="Comment">//: We have two transforms in previous layers -- for computing sizes and</span>
<span class="Comment">//: offsets containing addresses for containers and exclusive containers --</span>
<span class="Comment">//: that we need to teach about type ingredients.</span>

<span class="Delimiter">:(before &quot;End compute_container_sizes Non-atom Cases&quot;)</span>
<span class="Normal">const</span> type_tree* root = root_type<span class="Delimiter">(</span>type<span class="Delimiter">);</span>
type_info&amp; info = get<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> root<span class="Delimiter">-&gt;</span>value<span class="Delimiter">);</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>info<span class="Delimiter">.</span>kind == CONTAINER<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  compute_container_sizes<span class="Delimiter">(</span>info<span class="Delimiter">,</span> type<span class="Delimiter">,</span> pending_metadata<span class="Delimiter">);</span>
  <span class="Identifier">return</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>info<span class="Delimiter">.</span>kind == EXCLUSIVE_CONTAINER<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  compute_exclusive_container_sizes<span class="Delimiter">(</span>info<span class="Delimiter">,</span> type<span class="Delimiter">,</span> pending_metadata<span class="Delimiter">);</span>
  <span class="Identifier">return</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Unit Tests&quot;)</span>
<span class="Normal">void</span> test_container_sizes_shape_shifting_container<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_t [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:_t</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent r<span class="Delimiter">(</span><span class="Constant">&quot;x:foo:point&quot;</span><span class="Delimiter">);</span>
  compute_container_sizes<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>size<span class="Delimiter">,</span> <span class="Constant">3</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_container_sizes_shape_shifting_exclusive_container<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;exclusive-container foo:_t [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:_t</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent r<span class="Delimiter">(</span><span class="Constant">&quot;x:foo:point&quot;</span><span class="Delimiter">);</span>
  compute_container_sizes<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>size<span class="Delimiter">,</span> <span class="Constant">3</span><span class="Delimiter">);</span>
  reagent r2<span class="Delimiter">(</span><span class="Constant">&quot;x:foo:number&quot;</span><span class="Delimiter">);</span>
  compute_container_sizes<span class="Delimiter">(</span>r2<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>r2<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>size<span class="Delimiter">,</span> <span class="Constant">2</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_container_sizes_compound_type_ingredient<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_t [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:_t</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent r<span class="Delimiter">(</span><span class="Constant">&quot;x:foo:address:point&quot;</span><span class="Delimiter">);</span>
  compute_container_sizes<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>size<span class="Delimiter">,</span> <span class="Constant">2</span><span class="Delimiter">);</span>
  <span class="Comment">// scan also pre-computes metadata for type ingredient</span>
  reagent point<span class="Delimiter">(</span><span class="Constant">&quot;x:point&quot;</span><span class="Delimiter">);</span>
  CHECK<span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>Container_metadata<span class="Delimiter">,</span> point<span class="Delimiter">.</span>type<span class="Delimiter">));</span>
  CHECK_EQ<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Container_metadata<span class="Delimiter">,</span> point<span class="Delimiter">.</span>type<span class="Delimiter">).</span>size<span class="Delimiter">,</span> <span class="Constant">2</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_container_sizes_recursive_shape_shifting_container<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_t [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:address:foo:_t</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent r2<span class="Delimiter">(</span><span class="Constant">&quot;x:foo:number&quot;</span><span class="Delimiter">);</span>
  compute_container_sizes<span class="Delimiter">(</span>r2<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>r2<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>size<span class="Delimiter">,</span> <span class="Constant">2</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End compute_container_address_offsets Non-atom Cases&quot;)</span>
<span class="Normal">const</span> type_tree* root = root_type<span class="Delimiter">(</span>type<span class="Delimiter">);</span>
type_info&amp; info = get<span class="Delimiter">(</span>Type<span class="Delimiter">,</span> root<span class="Delimiter">-&gt;</span>value<span class="Delimiter">);</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>info<span class="Delimiter">.</span>kind == CONTAINER<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  compute_container_address_offsets<span class="Delimiter">(</span>info<span class="Delimiter">,</span> type<span class="Delimiter">);</span>
  <span class="Identifier">return</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>info<span class="Delimiter">.</span>kind == EXCLUSIVE_CONTAINER<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  compute_exclusive_container_address_offsets<span class="Delimiter">(</span>info<span class="Delimiter">,</span> type<span class="Delimiter">);</span>
  <span class="Identifier">return</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Unit Tests&quot;)</span>
<span class="Normal">void</span> test_container_address_offsets_in_shape_shifting_container<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_t [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:_t</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent r<span class="Delimiter">(</span><span class="Constant">&quot;x:foo:address:number&quot;</span><span class="Delimiter">);</span>
  compute_container_sizes<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  compute_container_address_offsets<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>address<span class="Delimiter">),</span> <span class="Constant">1</span><span class="Delimiter">);</span>
  CHECK<span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>address<span class="Delimiter">,</span> set&lt;tag_condition_info&gt;<span class="Delimiter">()));</span>
  set&lt;address_element_info&gt;&amp; offset_info = get<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>address<span class="Delimiter">,</span> set&lt;tag_condition_info&gt;<span class="Delimiter">());</span>
  CHECK_EQ<span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>offset_info<span class="Delimiter">),</span> <span class="Constant">1</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">()-&gt;</span>offset<span class="Delimiter">,</span> <span class="Constant">1</span><span class="Delimiter">);</span>  <span class="Comment">//</span>
  CHECK<span class="Delimiter">(</span>offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">()-&gt;</span>payload_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">()-&gt;</span>payload_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">,</span> <span class="Constant">&quot;number&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="Normal">void</span> test_container_address_offsets_in_nested_shape_shifting_container<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Constant">&quot;container foo:_t [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:number</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:_t</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;container bar:_t [</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  x:_t</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;  y:foo:_t</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span>
      <span class="Constant">&quot;]</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span><span class="Delimiter">);</span>
  reagent r<span class="Delimiter">(</span><span class="Constant">&quot;x:bar:address:number&quot;</span><span class="Delimiter">);</span>
  CLEAR_TRACE<span class="Delimiter">;</span>
  compute_container_sizes<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  compute_container_address_offsets<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>address<span class="Delimiter">),</span> <span class="Constant">1</span><span class="Delimiter">);</span>
  CHECK<span class="Delimiter">(</span>contains_key<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>address<span class="Delimiter">,</span> set&lt;tag_condition_info&gt;<span class="Delimiter">()));</span>
  set&lt;address_element_info&gt;&amp; offset_info = get<span class="Delimiter">(</span>r<span class="Delimiter">.</span>metadata<span class="Delimiter">.</span>address<span class="Delimiter">,</span> set&lt;tag_condition_info&gt;<span class="Delimiter">());</span>
  CHECK_EQ<span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>offset_info<span class="Delimiter">),</span> <span class="Constant">2</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">()-&gt;</span>offset<span class="Delimiter">,</span> <span class="Constant">0</span><span class="Delimiter">);</span>  <span class="Comment">//</span>
  CHECK<span class="Delimiter">(</span>offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">()-&gt;</span>payload_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">(</span>offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">()-&gt;</span>payload_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">,</span> <span class="Constant">&quot;number&quot;</span><span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">((</span>++offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">())-&gt;</span>offset<span class="Delimiter">,</span> <span class="Constant">2</span><span class="Delimiter">);</span>  <span class="Comment">//</span>
  CHECK<span class="Delimiter">((</span>++offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">())-&gt;</span>payload_type<span class="Delimiter">-&gt;</span>atom<span class="Delimiter">);</span>
  CHECK_EQ<span class="Delimiter">((</span>++offset_info<span class="Delimiter">.</span>begin<span class="Delimiter">())-&gt;</span>payload_type<span class="Delimiter">-&gt;</span>name<span class="Delimiter">,</span> <span class="Constant">&quot;number&quot;</span><span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: 'merge' on shape-shifting containers</span>

<span class="Delimiter">:(scenario merge_check_shape_shifting_container_containing_exclusive_container)</span>
container foo:_elem [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:_elem
]
exclusive-container bar [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:bar<span class="Special"> &lt;- </span>merge <span class="Constant">23</span><span class="Delimiter">,</span> <span class="Constant">1</span>/y<span class="Delimiter">,</span> <span class="Constant">34</span>
]
<span class="traceContains">+mem: storing 23 in location 1</span>
<span class="traceContains">+mem: storing 1 in location 2</span>
<span class="traceContains">+mem: storing 34 in location 3</span>
$error: <span class="Constant">0</span>

<span class="Delimiter">:(scenario merge_check_shape_shifting_container_containing_exclusive_container_2)</span>
<span class="Special">% Hide_errors = true;</span>
container foo:_elem [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:_elem
]
exclusive-container bar [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:bar<span class="Special"> &lt;- </span>merge <span class="Constant">23</span><span class="Delimiter">,</span> <span class="Constant">1</span>/y<span class="Delimiter">,</span> <span class="Constant">34</span><span class="Delimiter">,</span> <span class="Constant">35</span>
]
<span class="traceContains">+error: main: too many ingredients in '1:foo:bar &lt;- merge 23, 1/y, 34, 35'</span>

<span class="Delimiter">:(scenario merge_check_shape_shifting_exclusive_container_containing_container)</span>
exclusive-container foo:_elem [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:_elem
]
container bar [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:bar<span class="Special"> &lt;- </span>merge <span class="Constant">1</span>/y<span class="Delimiter">,</span> <span class="Constant">23</span><span class="Delimiter">,</span> <span class="Constant">34</span>
]
<span class="traceContains">+mem: storing 1 in location 1</span>
<span class="traceContains">+mem: storing 23 in location 2</span>
<span class="traceContains">+mem: storing 34 in location 3</span>
$error: <span class="Constant">0</span>

<span class="Delimiter">:(scenario merge_check_shape_shifting_exclusive_container_containing_container_2)</span>
exclusive-container foo:_elem [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:_elem
]
container bar [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:bar<span class="Special"> &lt;- </span>merge <span class="Constant">0</span>/x<span class="Delimiter">,</span> <span class="Constant">23</span>
]
$error: <span class="Constant">0</span>

<span class="Delimiter">:(scenario merge_check_shape_shifting_exclusive_container_containing_container_3)</span>
<span class="Special">% Hide_errors = true;</span>
exclusive-container foo:_elem [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:_elem
]
container bar [
  <span class="Normal">x</span>:number
  <span class="Normal">y</span>:number
]
def main [
  <span class="Constant">1</span>:foo:bar<span class="Special"> &lt;- </span>merge <span class="Constant">1</span>/y<span class="Delimiter">,</span> <span class="Constant">23</span>
]
<span class="traceContains">+error: main: too few ingredients in '1:foo:bar &lt;- merge 1/y, 23'</span>

<span class="Delimiter">:(before &quot;End variant_type Special-cases&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>contains_type_ingredient<span class="Delimiter">(</span>element<span class="Delimiter">))</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">)</span>
    raise &lt;&lt; <span class="Constant">&quot;illegal type &quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>type<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot; seems to be missing a type ingredient or three</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
  replace_type_ingredients<span class="Delimiter">(</span>element<span class="Delimiter">.</span>type<span class="Delimiter">,</span> type<span class="Delimiter">-&gt;</span>right<span class="Delimiter">,</span> info<span class="Delimiter">);</span>
<span class="Delimiter">}</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
