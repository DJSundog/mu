<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Mu - 072scheduler.cc</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="cpp">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="minimal">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #eeeeee; background-color: #080808; }
body { font-size: 12pt; font-family: monospace; color: #eeeeee; background-color: #080808; }
* { font-size: 12pt; font-size: 1em; }
.Constant { color: #00a0a0; }
.traceAbsent { color: #c00000; }
.cSpecial { color: #008000; }
.muRecipe { color: #ff8700; }
.SalientComment { color: #00ffff; }
.Comment { color: #9090ff; }
.Delimiter { color: #800080; }
.Special { color: #c00000; }
.traceContains { color: #008000; }
.Normal { color: #eeeeee; background-color: #080808; padding-bottom: 1px; }
.Identifier { color: #fcb165; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">//: Run a second routine concurrently using 'start-running', without any</span>
<span class="Comment">//: guarantees on how the operations in each are interleaved with each other.</span>

<span class="Delimiter">:(scenario scheduler)</span>
<span class="muRecipe">def</span> f1 [
  start-running f2
  <span class="Comment"># wait for f2 to run</span>
  <span class="Delimiter">{</span>
    jump-unless <span class="Constant">1</span>:num<span class="Delimiter">,</span> -<span class="Constant">1</span>
  <span class="Delimiter">}</span>
]
<span class="muRecipe">def</span> f2 [
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">1</span>
]
<span class="traceContains">+schedule: f1</span>
<span class="traceContains">+schedule: f2</span>

<span class="Comment">//: first, add a deadline to run(routine)</span>
<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
<span class="Normal">int</span> Scheduling_interval = <span class="Constant">500</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End routine Fields&quot;)</span>
<span class="Normal">int</span> instructions_run_this_scheduling_slice<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End routine Constructor&quot;)</span>
instructions_run_this_scheduling_slice = <span class="Constant">0</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;Running One Instruction&quot;)</span>
 ++Current_routine<span class="Delimiter">-&gt;</span>instructions_run_this_scheduling_slice<span class="Delimiter">;</span>
<span class="Delimiter">:(replace{} &quot;bool should_continue_running(const routine* current_routine)&quot;)</span>
<span class="Normal">bool</span> should_continue_running<span class="Delimiter">(</span><span class="Normal">const</span> routine* current_routine<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  assert<span class="Delimiter">(</span>current_routine == Current_routine<span class="Delimiter">);</span>  <span class="Comment">// argument passed in just to make caller readable above</span>
  <span class="Identifier">return</span> Current_routine<span class="Delimiter">-&gt;</span>state == RUNNING
      &amp;&amp; Current_routine<span class="Delimiter">-&gt;</span>instructions_run_this_scheduling_slice &lt; Scheduling_interval<span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(after &quot;stop_running_current_routine:&quot;)</span>
<span class="Comment">// Reset instructions_run_this_scheduling_slice</span>
Current_routine<span class="Delimiter">-&gt;</span>instructions_run_this_scheduling_slice = <span class="Constant">0</span><span class="Delimiter">;</span>

<span class="Comment">//: now the rest of the scheduler is clean</span>

<span class="Delimiter">:(before &quot;struct routine&quot;)</span>
<span class="Normal">enum</span> routine_state <span class="Delimiter">{</span>
  RUNNING<span class="Delimiter">,</span>
  COMPLETED<span class="Delimiter">,</span>
  <span class="Comment">// End routine States</span>
<span class="Delimiter">};</span>
<span class="Delimiter">:(before &quot;End routine Fields&quot;)</span>
<span class="Normal">enum</span> routine_state state<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End routine Constructor&quot;)</span>
state = RUNNING<span class="Delimiter">;</span>

<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
vector&lt;routine*&gt; Routines<span class="Delimiter">;</span>
<span class="Normal">int</span> Current_routine_index = <span class="Constant">0</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
Scheduling_interval = <span class="Constant">500</span><span class="Delimiter">;</span>
Routines<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
<span class="Delimiter">:(replace{} &quot;void run(recipe_ordinal r)&quot;)</span>
<span class="Normal">void</span> run<span class="Delimiter">(</span>recipe_ordinal r<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  run<span class="Delimiter">(</span><span class="Normal">new</span> routine<span class="Delimiter">(</span>r<span class="Delimiter">));</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
<span class="Normal">void</span> run<span class="Delimiter">(</span>routine* rr<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  Routines<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>rr<span class="Delimiter">);</span>
  Current_routine_index = <span class="Constant">0</span><span class="Delimiter">,</span> Current_routine = Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Normal">while</span> <span class="Delimiter">(</span>!all_routines_done<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    skip_to_next_routine<span class="Delimiter">();</span>
    assert<span class="Delimiter">(</span>Current_routine<span class="Delimiter">);</span>
    assert<span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>state == RUNNING<span class="Delimiter">);</span>
    trace<span class="Delimiter">(</span><span class="Constant">9990</span><span class="Delimiter">,</span> <span class="Constant">&quot;schedule&quot;</span><span class="Delimiter">)</span> &lt;&lt; current_routine_label<span class="Delimiter">()</span> &lt;&lt; end<span class="Delimiter">();</span>
    run_current_routine<span class="Delimiter">();</span>
    <span class="Comment">// Scheduler State Transitions</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>completed<span class="Delimiter">())</span>
      Current_routine<span class="Delimiter">-&gt;</span>state = COMPLETED<span class="Delimiter">;</span>
    <span class="Comment">// End Scheduler State Transitions</span>

    <span class="Comment">// Scheduler Cleanup</span>
    <span class="Comment">// End Scheduler Cleanup</span>
  <span class="Delimiter">}</span>
  <span class="Comment">// End Run Routine</span>
<span class="Delimiter">}</span>

<span class="Normal">bool</span> all_routines_done<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>state == RUNNING<span class="Delimiter">)</span>
      <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Comment">// skip Current_routine_index past non-RUNNING routines</span>
<span class="Normal">void</span> skip_to_next_routine<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  assert<span class="Delimiter">(</span>!Routines<span class="Delimiter">.</span>empty<span class="Delimiter">());</span>
  assert<span class="Delimiter">(</span>Current_routine_index &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">));</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Delimiter">(</span>Current_routine_index+<span class="Constant">1</span><span class="Delimiter">)</span>%SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  i != Current_routine_index<span class="Delimiter">;</span>  i = <span class="Delimiter">(</span>i+<span class="Constant">1</span><span class="Delimiter">)</span>%SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>state == RUNNING<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      Current_routine_index = i<span class="Delimiter">;</span>
      Current_routine = Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
      <span class="Identifier">return</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

string current_routine_label<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Identifier">return</span> routine_label<span class="Delimiter">(</span>Current_routine<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

string routine_label<span class="Delimiter">(</span>routine* r<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  ostringstream result<span class="Delimiter">;</span>
  <span class="Normal">const</span> call_stack&amp; calls = r<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span>call_stack::const_iterator p = calls<span class="Delimiter">.</span>begin<span class="Delimiter">();</span>  p != calls<span class="Delimiter">.</span>end<span class="Delimiter">();</span>  ++p<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>p != calls<span class="Delimiter">.</span>begin<span class="Delimiter">())</span> result &lt;&lt; <span class="Constant">'/'</span><span class="Delimiter">;</span>
    result &lt;&lt; get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> p<span class="Delimiter">-&gt;</span>running_recipe<span class="Delimiter">).</span>name<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> result<span class="Delimiter">.</span>str<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Teardown&quot;)</span>
<span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span>
  <span class="Normal">delete</span> Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
Routines<span class="Delimiter">.</span>clear<span class="Delimiter">();</span>
Current_routine = <span class="Constant">NULL</span><span class="Delimiter">;</span>

<span class="Comment">//: special case for the very first routine</span>
<span class="Delimiter">:(replace{} &quot;void run_main(int argc, char* argv[])&quot;)</span>
<span class="Normal">void</span> run_main<span class="Delimiter">(</span><span class="Normal">int</span> argc<span class="Delimiter">,</span> <span class="Normal">char</span>* argv[]<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  recipe_ordinal r = get<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;main&quot;</span><span class="Delimiter">);</span>
  assert<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  routine* main_routine = <span class="Normal">new</span> routine<span class="Delimiter">(</span>r<span class="Delimiter">);</span>
  <span class="Comment">// pass in commandline args as ingredients to main</span>
  <span class="Comment">// todo: test this</span>
  Current_routine = main_routine<span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">1</span><span class="Delimiter">;</span>  i &lt; argc<span class="Delimiter">;</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    vector&lt;<span class="Normal">double</span>&gt; arg<span class="Delimiter">;</span>
    arg<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>new_mu_text<span class="Delimiter">(</span>argv[i]<span class="Delimiter">));</span>
    current_call<span class="Delimiter">().</span>ingredient_atoms<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>arg<span class="Delimiter">);</span>
  <span class="Delimiter">}</span>
  run<span class="Delimiter">(</span>main_routine<span class="Delimiter">);</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: To schedule new routines to run, call 'start-running'.</span>

<span class="Comment">//: 'start-running' will return a unique id for the routine that was created.</span>
<span class="Comment">//: routine id is a number, but don't do any arithmetic on it</span>
<span class="Delimiter">:(before &quot;End routine Fields&quot;)</span>
<span class="Normal">int</span> id<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Globals&quot;)</span>
<span class="Normal">int</span> Next_routine_id = <span class="Constant">1</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Setup&quot;)</span>
Next_routine_id = <span class="Constant">1</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End routine Constructor&quot;)</span>
id = Next_routine_id<span class="Delimiter">;</span>
<span class="traceContains">++Next_routine_id;</span>

<span class="Comment">//: routines save the routine that spawned them</span>
<span class="Delimiter">:(before &quot;End routine Fields&quot;)</span>
<span class="Comment">// todo: really should be routine_id, but that's less efficient.</span>
<span class="Normal">int</span> parent_index<span class="Delimiter">;</span>  <span class="Comment">// only &lt; 0 if there's no parent_index</span>
<span class="Delimiter">:(before &quot;End routine Constructor&quot;)</span>
parent_index = -<span class="Constant">1</span><span class="Delimiter">;</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
START_RUNNING<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;start-running&quot;</span><span class="Delimiter">,</span> START_RUNNING<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
<span class="Normal">case</span> START_RUNNING: <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>empty<span class="Delimiter">())</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'start-running' requires at least one ingredient: the recipe to start running</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!is_mu_recipe<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;first ingredient of 'start-running' should be a recipe, but got '&quot;</span> &lt;&lt; to_string<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">))</span> &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
<span class="Normal">case</span> START_RUNNING: <span class="Delimiter">{</span>
  routine* new_routine = <span class="Normal">new</span> routine<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">));</span>
  new_routine<span class="Delimiter">-&gt;</span>parent_index = Current_routine_index<span class="Delimiter">;</span>
  <span class="Comment">// populate ingredients</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">1</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    new_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>front<span class="Delimiter">().</span>ingredient_atoms<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
    reagent<span class="Comment">/*</span><span class="Comment">copy</span><span class="Comment">*/</span> ingredient = current_instruction<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">);</span>
    canonize_type<span class="Delimiter">(</span>ingredient<span class="Delimiter">);</span>
    new_routine<span class="Delimiter">-&gt;</span>calls<span class="Delimiter">.</span>front<span class="Delimiter">().</span>ingredients<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>ingredient<span class="Delimiter">);</span>
    <span class="Comment">// End Populate start-running Ingredient</span>
  <span class="Delimiter">}</span>
  Routines<span class="Delimiter">.</span>push_back<span class="Delimiter">(</span>new_routine<span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>resize<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>push_back<span class="Delimiter">(</span>new_routine<span class="Delimiter">-&gt;</span>id<span class="Delimiter">);</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario scheduler_runs_single_routine)</span>
<span class="Special">% Scheduling_interval = 1;</span>
<span class="muRecipe">def</span> f1 [
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
<span class="traceContains">+schedule: f1</span>
<span class="traceContains">+run: {1: &quot;number&quot;} &lt;- copy {0: &quot;literal&quot;}</span>
<span class="traceContains">+schedule: f1</span>
<span class="traceContains">+run: {2: &quot;number&quot;} &lt;- copy {0: &quot;literal&quot;}</span>

<span class="Delimiter">:(scenario scheduler_interleaves_routines)</span>
<span class="Special">% Scheduling_interval = 1;</span>
<span class="muRecipe">def</span> f1 [
  start-running f2
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
<span class="muRecipe">def</span> f2 [
  <span class="Constant">3</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Constant">4</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
<span class="traceContains">+schedule: f1</span>
<span class="traceContains">+run: start-running {f2: &quot;recipe-literal&quot;}</span>
<span class="traceContains">+schedule: f2</span>
<span class="traceContains">+run: {3: &quot;number&quot;} &lt;- copy {0: &quot;literal&quot;}</span>
<span class="traceContains">+schedule: f1</span>
<span class="traceContains">+run: {1: &quot;number&quot;} &lt;- copy {0: &quot;literal&quot;}</span>
<span class="traceContains">+schedule: f2</span>
<span class="traceContains">+run: {4: &quot;number&quot;} &lt;- copy {0: &quot;literal&quot;}</span>
<span class="traceContains">+schedule: f1</span>
<span class="traceContains">+run: {2: &quot;number&quot;} &lt;- copy {0: &quot;literal&quot;}</span>

<span class="Delimiter">:(scenario start_running_takes_ingredients)</span>
<span class="muRecipe">def</span> f1 [
  start-running f2<span class="Delimiter">,</span> <span class="Constant">3</span>
  <span class="Comment"># wait for f2 to run</span>
  <span class="Delimiter">{</span>
    jump-unless <span class="Constant">1</span>:num<span class="Delimiter">,</span> -<span class="Constant">1</span>
  <span class="Delimiter">}</span>
]
<span class="muRecipe">def</span> f2 [
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>next-ingredient
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>add <span class="Constant">1</span>:num<span class="Delimiter">,</span> <span class="Constant">1</span>
]
<span class="traceContains">+mem: storing 4 in location 2</span>

<span class="Comment">//: more complex: refcounting management when starting up new routines</span>

<span class="Delimiter">:(scenario start_running_immediately_updates_refcounts_of_ingredients)</span>
<span class="Special">% Scheduling_interval = 1;</span>
<span class="muRecipe">def</span> main [
  local-scope
  create-<span class="Normal">new</span>-routine
  <span class="Comment"># padding to make sure we run new-routine before returning</span>
  <span class="Normal">dummy</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Normal">dummy</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
<span class="muRecipe">def</span> create-<span class="Normal">new</span>-routine [
  local-scope
  <span class="Normal">n</span>:&amp;:num<span class="Special"> &lt;- </span><span class="Normal">new</span> <span class="Constant">number:type</span>
  *n<span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
  start-running <span class="Normal">new</span>-routine<span class="Delimiter">,</span> n
  <span class="Comment"># refcount of n decremented</span>
]
<span class="muRecipe">def</span> <span class="Normal">new</span>-routine n:&amp;:num [
  local-scope
  load-ingredients
  <span class="Constant">1</span>:num/<span class="Special">raw &lt;- </span>copy *n
]
<span class="Comment"># check that n wasn't reclaimed when create-new-routine returned</span>
<span class="traceContains">+mem: storing 34 in location 1</span>

<span class="Comment">//: to support the previous scenario we'll increment refcounts for all call</span>
<span class="Comment">//: ingredients right at call time, and stop incrementing refcounts inside</span>
<span class="Comment">//: next-ingredient</span>
<span class="Delimiter">:(before &quot;End Populate Call Ingredient&quot;)</span>
increment_any_refcounts<span class="Delimiter">(</span>ingredient<span class="Delimiter">,</span> ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
<span class="Delimiter">:(before &quot;End Populate start-running Ingredient&quot;)</span>
increment_any_refcounts<span class="Delimiter">(</span>ingredient<span class="Delimiter">,</span> ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">));</span>
<span class="Delimiter">:(before &quot;End should_update_refcounts_in_write_memory Special-cases For Primitives&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>inst<span class="Delimiter">.</span>operation == NEXT_INGREDIENT || inst<span class="Delimiter">.</span>operation == NEXT_INGREDIENT_WITHOUT_TYPECHECKING<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>space_index<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">))</span> &gt; <span class="Constant">0</span><span class="Delimiter">)</span> <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>has_property<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">),</span> <span class="Constant">&quot;raw&quot;</span><span class="Delimiter">))</span> <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario next_ingredient_never_leaks_refcounts)</span>
<span class="muRecipe">def</span> create-space n:&amp;:num<span class="muRecipe"> -&gt; </span><span class="Normal">default</span>-space:space [
  <span class="Normal">default</span>-space<span class="Special"> &lt;- </span><span class="Normal">new</span> <span class="Constant">location:type</span><span class="Delimiter">,</span> <span class="Constant">2</span>
  load-ingredients
]
<span class="muRecipe">def</span> use-space [
  local-scope
  <span class="Constant">0</span>:space/names:create-space<span class="Special"> &lt;- </span>next-ingredient
  <span class="Normal">n</span>:&amp;:num/space:<span class="Constant">1</span><span class="Special"> &lt;- </span>next-ingredient  <span class="Comment"># should decrement refcount</span>
  *n/space:<span class="Constant">1</span><span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
  <span class="Normal">n2</span>:num<span class="Special"> &lt;- </span>add *n/space:<span class="Constant">1</span><span class="Delimiter">,</span> <span class="Constant">1</span>
  reply n2
]
<span class="muRecipe">def</span> main [
  local-scope
  <span class="Normal">n</span>:&amp;:num<span class="Special"> &lt;- </span>copy <span class="Constant">12000</span>/unsafe  <span class="Comment"># pretend allocation with a known address</span>
  *n<span class="Special"> &lt;- </span>copy <span class="Constant">23</span>
  <span class="Normal">space</span>:space<span class="Special"> &lt;- </span>create-space n
  <span class="Normal">n2</span>:&amp;:num<span class="Special"> &lt;- </span>copy <span class="Constant">13000</span>/unsafe
  <span class="Normal">n3</span>:num<span class="Special"> &lt;- </span>use-space space<span class="Delimiter">,</span> n2
]
<span class="traceContains">+run: {n: (&quot;address&quot; &quot;number&quot;), &quot;space&quot;: &quot;1&quot;} &lt;- next-ingredient</span>
<span class="traceContains">+mem: decrementing refcount of 12000: 2 -&gt; 1</span>
<span class="traceContains">+run: {n: (&quot;address&quot; &quot;number&quot;), &quot;space&quot;: &quot;1&quot;, &quot;lookup&quot;: ()} &lt;- copy {34: &quot;literal&quot;}</span>

<span class="Comment">//: back to testing 'start-running'</span>

<span class="Delimiter">:(scenario start_running_returns_routine_id)</span>
<span class="muRecipe">def</span> f1 [
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>start-running f2
]
<span class="muRecipe">def</span> f2 [
  <span class="Constant">12</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">44</span>
]
<span class="traceContains">+mem: storing 2 in location 1</span>

<span class="Comment">//: this scenario will require some careful setup in escaped C++</span>
<span class="Comment">//: (straining our tangle capabilities to near-breaking point)</span>
<span class="Delimiter">:(scenario scheduler_skips_completed_routines)</span>
<span class="Special">% recipe_ordinal f1 = load(&quot;recipe f1 [\n1:num &lt;- copy 0\n]\n&quot;).front();</span>
<span class="Special">% recipe_ordinal f2 = load(&quot;recipe f2 [\n2:num &lt;- copy 0\n]\n&quot;).front();</span>
<span class="Special">% Routines.push_back(new routine(f1));  // f1 meant to run</span>
<span class="Special">% Routines.push_back(new routine(f2));</span>
<span class="Special">% Routines.back()-&gt;state = COMPLETED;  // f2 not meant to run</span>
<span class="Comment"># must have at least one routine without escaping</span>
<span class="muRecipe">def</span> f3 [
  <span class="Constant">3</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
<span class="Comment"># by interleaving '+' lines with '-' lines, we allow f1 and f3 to run in any order</span>
<span class="traceContains">+schedule: f1</span>
<span class="traceContains">+mem: storing 0 in location 1</span>
<span class="traceAbsent">-schedule: f2</span>
<span class="traceAbsent">-mem: storing 0 in location 2</span>
<span class="traceContains">+schedule: f3</span>
<span class="traceContains">+mem: storing 0 in location 3</span>

<span class="Delimiter">:(scenario scheduler_starts_at_middle_of_routines)</span>
<span class="Special">% Routines.push_back(new routine(COPY));</span>
<span class="Special">% Routines.back()-&gt;state = COMPLETED;</span>
<span class="muRecipe">def</span> f1 [
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
<span class="traceContains">+schedule: f1</span>
<span class="traceAbsent">-run: idle</span>

<span class="SalientComment">//:: Errors in a routine cause it to terminate.</span>

<span class="Delimiter">:(scenario scheduler_terminates_routines_after_errors)</span>
<span class="Special">% Hide_errors = true;</span>
<span class="Special">% Scheduling_interval = 2;</span>
<span class="muRecipe">def</span> f1 [
  start-running f2
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
<span class="muRecipe">def</span> f2 [
  <span class="Comment"># divide by 0 twice</span>
  <span class="Constant">3</span>:num<span class="Special"> &lt;- </span>divide-with-remainder <span class="Constant">4</span><span class="Delimiter">,</span> <span class="Constant">0</span>
  <span class="Constant">4</span>:num<span class="Special"> &lt;- </span>divide-with-remainder <span class="Constant">4</span><span class="Delimiter">,</span> <span class="Constant">0</span>
]
<span class="Comment"># f2 should stop after first divide by 0</span>
<span class="traceContains">+error: f2: divide by zero in '3:num &lt;- divide-with-remainder 4, 0'</span>
<span class="traceAbsent">-error: f2: divide by zero in '4:num &lt;- divide-with-remainder 4, 0'</span>

<span class="Delimiter">:(after &quot;operator&lt;&lt;(ostream&amp; os, unused end)&quot;)</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>Trace_stream &amp;&amp; Trace_stream<span class="Delimiter">-&gt;</span>curr_label == <span class="Constant">&quot;error&quot;</span> &amp;&amp; Current_routine<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    Current_routine<span class="Delimiter">-&gt;</span>state = COMPLETED<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>

<span class="SalientComment">//:: Routines are marked completed when their parent completes.</span>

<span class="Delimiter">:(scenario scheduler_kills_orphans)</span>
<span class="muRecipe">def</span> main [
  start-running f1
  <span class="Comment"># f1 never actually runs because its parent completes without waiting for it</span>
]
<span class="muRecipe">def</span> f1 [
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
]
<span class="traceAbsent">-schedule: f1</span>

<span class="Delimiter">:(before &quot;End Scheduler Cleanup&quot;)</span>
<span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>state == COMPLETED<span class="Delimiter">)</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>parent_index &lt; <span class="Constant">0</span><span class="Delimiter">)</span> <span class="Identifier">continue</span><span class="Delimiter">;</span>  <span class="Comment">// root thread</span>
  <span class="Comment">// structured concurrency: <a href="http://250bpm.com/blog:71">http://250bpm.com/blog:71</a></span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>has_completed_parent<span class="Delimiter">(</span>i<span class="Delimiter">))</span> <span class="Delimiter">{</span>
    Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>state = COMPLETED<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
<span class="Normal">bool</span> has_completed_parent<span class="Delimiter">(</span><span class="Normal">int</span> routine_index<span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> j = routine_index<span class="Delimiter">;</span>  j &gt;= <span class="Constant">0</span><span class="Delimiter">;</span>  j = Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>j<span class="Delimiter">)-&gt;</span>parent_index<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>j<span class="Delimiter">)-&gt;</span>state == COMPLETED<span class="Delimiter">)</span>
      <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: 'routine-state' can tell if a given routine id is running</span>

<span class="Delimiter">:(scenario routine_state_test)</span>
<span class="Special">% Scheduling_interval = 2;</span>
<span class="muRecipe">def</span> f1 [
  <span class="Constant">1</span>:num/child-id<span class="Special"> &lt;- </span>start-running f2
  <span class="Constant">12</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>  <span class="Comment"># race condition since we don't care about location 12</span>
  <span class="Comment"># thanks to Scheduling_interval, f2's one instruction runs in between here and completes</span>
  <span class="Constant">2</span>:num/state<span class="Special"> &lt;- </span>routine-state <span class="Constant">1</span>:num/child-id
]
<span class="muRecipe">def</span> f2 [
  <span class="Constant">12</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">0</span>
  <span class="Comment"># trying to run a second instruction marks routine as completed</span>
]
<span class="Comment"># recipe f2 should be in state COMPLETED</span>
<span class="traceContains">+mem: storing 1 in location 2</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
ROUTINE_STATE<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;routine-state&quot;</span><span class="Delimiter">,</span> ROUTINE_STATE<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
<span class="Normal">case</span> ROUTINE_STATE: <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">)</span> != <span class="Constant">1</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'routine-state' requires exactly one ingredient, but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!is_mu_number<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;first ingredient of 'routine-state' should be a routine id generated by 'start-running', but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
<span class="Normal">case</span> ROUTINE_STATE: <span class="Delimiter">{</span>
  <span class="Normal">int</span> id = ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Normal">int</span> result = -<span class="Constant">1</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>id == id<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      result = Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>state<span class="Delimiter">;</span>
      <span class="Identifier">break</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  products<span class="Delimiter">.</span>resize<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>push_back<span class="Delimiter">(</span>result<span class="Delimiter">);</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="SalientComment">//:: miscellaneous helpers</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
STOP<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;stop&quot;</span><span class="Delimiter">,</span> STOP<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
<span class="Normal">case</span> STOP: <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">)</span> != <span class="Constant">1</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'stop' requires exactly one ingredient, but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!is_mu_number<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;first ingredient of 'stop' should be a routine id generated by 'start-running', but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
<span class="Normal">case</span> STOP: <span class="Delimiter">{</span>
  <span class="Normal">int</span> id = ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>id == id<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>state = COMPLETED<span class="Delimiter">;</span>
      <span class="Identifier">break</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
_DUMP_ROUTINES<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;$dump-routines&quot;</span><span class="Delimiter">,</span> _DUMP_ROUTINES<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
<span class="Normal">case</span> _DUMP_ROUTINES: <span class="Delimiter">{</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
<span class="Normal">case</span> _DUMP_ROUTINES: <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    cerr &lt;&lt; i &lt;&lt; <span class="Constant">&quot;: &quot;</span> &lt;&lt; Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>id &lt;&lt; <span class="Constant">' '</span> &lt;&lt; Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>state &lt;&lt; <span class="Constant">' '</span> &lt;&lt; Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>parent_index &lt;&lt; <span class="cSpecial">'\n'</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Comment">//: support for stopping routines after some number of cycles</span>

<span class="Delimiter">:(scenario routine_discontinues_past_limit)</span>
<span class="Special">% Scheduling_interval = 2;</span>
<span class="muRecipe">def</span> f1 [
  <span class="Constant">1</span>:num/child-id<span class="Special"> &lt;- </span>start-running f2
  limit-time <span class="Constant">1</span>:num/child-id<span class="Delimiter">,</span> <span class="Constant">10</span>
  <span class="Comment"># padding loop just to make sure f2 has time to completed</span>
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">20</span>
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>subtract <span class="Constant">2</span>:num<span class="Delimiter">,</span> <span class="Constant">1</span>
  jump-<span class="Normal">if</span> <span class="Constant">2</span>:num<span class="Delimiter">,</span> <span class="Constant">-2:offset</span>
]
<span class="muRecipe">def</span> f2 [
  jump <span class="Constant">-1:offset</span>  <span class="Comment"># run forever</span>
  $print [should never get here]<span class="Delimiter">,</span> <span class="Constant">10</span>/newline
]
<span class="Comment"># f2 terminates</span>
<span class="traceContains">+schedule: discontinuing routine 2</span>

<span class="Delimiter">:(before &quot;End routine States&quot;)</span>
DISCONTINUED<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Scheduler State Transitions&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>limit &gt;= <span class="Constant">0</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>Current_routine<span class="Delimiter">-&gt;</span>limit &lt;= Scheduling_interval<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    trace<span class="Delimiter">(</span><span class="Constant">9999</span><span class="Delimiter">,</span> <span class="Constant">&quot;schedule&quot;</span><span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;discontinuing routine &quot;</span> &lt;&lt; Current_routine<span class="Delimiter">-&gt;</span>id &lt;&lt; end<span class="Delimiter">();</span>
    Current_routine<span class="Delimiter">-&gt;</span>state = DISCONTINUED<span class="Delimiter">;</span>
    Current_routine<span class="Delimiter">-&gt;</span>limit = <span class="Constant">0</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">else</span> <span class="Delimiter">{</span>
    Current_routine<span class="Delimiter">-&gt;</span>limit -= Scheduling_interval<span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End Test Teardown&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>Passed &amp;&amp; any_routines_with_error<span class="Delimiter">())</span> <span class="Delimiter">{</span>
  Passed = <span class="Constant">false</span><span class="Delimiter">;</span>
  raise &lt;&lt; <span class="Constant">&quot;some routines died with errors</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End Mu Test Teardown&quot;)</span>
<span class="Normal">if</span> <span class="Delimiter">(</span>Passed &amp;&amp; any_routines_with_error<span class="Delimiter">())</span> <span class="Delimiter">{</span>
  Passed = <span class="Constant">false</span><span class="Delimiter">;</span>
  raise &lt;&lt; Current_scenario<span class="Delimiter">-&gt;</span>name &lt;&lt; <span class="Constant">&quot;: some routines died with errors</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(code)</span>
<span class="Normal">bool</span> any_routines_with_error<span class="Delimiter">()</span> <span class="Delimiter">{</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>state == DISCONTINUED<span class="Delimiter">)</span>
      <span class="Identifier">return</span> <span class="Constant">true</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">return</span> <span class="Constant">false</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End routine Fields&quot;)</span>
<span class="Normal">int</span> limit<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End routine Constructor&quot;)</span>
limit = -<span class="Constant">1</span><span class="Delimiter">;</span>  <span class="Comment">/*</span><span class="Comment"> no limit </span><span class="Comment">*/</span>

<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
LIMIT_TIME<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;limit-time&quot;</span><span class="Delimiter">,</span> LIMIT_TIME<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
<span class="Normal">case</span> LIMIT_TIME: <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">)</span> != <span class="Constant">2</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'limit-time' requires exactly two ingredient, but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!is_mu_number<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;first ingredient of 'limit-time' should be a routine id generated by 'start-running', but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!is_mu_number<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;second ingredient of 'limit-time' should be a number (of instructions to run for), but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">).</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
<span class="Normal">case</span> LIMIT_TIME: <span class="Delimiter">{</span>
  <span class="Normal">int</span> id = ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>id == id<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>limit = ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
      <span class="Identifier">break</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(before &quot;End routine Fields&quot;)</span>
<span class="Normal">int</span> instructions_run<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End routine Constructor&quot;)</span>
instructions_run = <span class="Constant">0</span><span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;Reset instructions_run_this_scheduling_slice&quot;)</span>
Current_routine<span class="Delimiter">-&gt;</span>instructions_run += Current_routine<span class="Delimiter">-&gt;</span>instructions_run_this_scheduling_slice<span class="Delimiter">;</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Declarations&quot;)</span>
NUMBER_OF_INSTRUCTIONS<span class="Delimiter">,</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Numbers&quot;)</span>
put<span class="Delimiter">(</span>Recipe_ordinal<span class="Delimiter">,</span> <span class="Constant">&quot;number-of-instructions&quot;</span><span class="Delimiter">,</span> NUMBER_OF_INSTRUCTIONS<span class="Delimiter">);</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Checks&quot;)</span>
<span class="Normal">case</span> NUMBER_OF_INSTRUCTIONS: <span class="Delimiter">{</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>SIZE<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">)</span> != <span class="Constant">1</span><span class="Delimiter">)</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;'number-of-instructions' requires exactly one ingredient, but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Normal">if</span> <span class="Delimiter">(</span>!is_mu_number<span class="Delimiter">(</span>inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">)))</span> <span class="Delimiter">{</span>
    raise &lt;&lt; maybe<span class="Delimiter">(</span>get<span class="Delimiter">(</span>Recipe<span class="Delimiter">,</span> r<span class="Delimiter">).</span>name<span class="Delimiter">)</span> &lt;&lt; <span class="Constant">&quot;first ingredient of 'number-of-instructions' should be a routine id generated by 'start-running', but got '&quot;</span> &lt;&lt; inst<span class="Delimiter">.</span>ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>original_string &lt;&lt; <span class="Constant">&quot;'</span><span class="cSpecial">\n</span><span class="Constant">&quot;</span> &lt;&lt; end<span class="Delimiter">();</span>
    <span class="Identifier">break</span><span class="Delimiter">;</span>
  <span class="Delimiter">}</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>
<span class="Delimiter">:(before &quot;End Primitive Recipe Implementations&quot;)</span>
<span class="Normal">case</span> NUMBER_OF_INSTRUCTIONS: <span class="Delimiter">{</span>
  <span class="Normal">int</span> id = ingredients<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">);</span>
  <span class="Normal">int</span> result = -<span class="Constant">1</span><span class="Delimiter">;</span>
  <span class="Normal">for</span> <span class="Delimiter">(</span><span class="Normal">int</span> i = <span class="Constant">0</span><span class="Delimiter">;</span>  i &lt; SIZE<span class="Delimiter">(</span>Routines<span class="Delimiter">);</span>  ++i<span class="Delimiter">)</span> <span class="Delimiter">{</span>
    <span class="Normal">if</span> <span class="Delimiter">(</span>Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>id == id<span class="Delimiter">)</span> <span class="Delimiter">{</span>
      result = Routines<span class="Delimiter">.</span>at<span class="Delimiter">(</span>i<span class="Delimiter">)-&gt;</span>instructions_run<span class="Delimiter">;</span>
      <span class="Identifier">break</span><span class="Delimiter">;</span>
    <span class="Delimiter">}</span>
  <span class="Delimiter">}</span>
  products<span class="Delimiter">.</span>resize<span class="Delimiter">(</span><span class="Constant">1</span><span class="Delimiter">);</span>
  products<span class="Delimiter">.</span>at<span class="Delimiter">(</span><span class="Constant">0</span><span class="Delimiter">).</span>push_back<span class="Delimiter">(</span>result<span class="Delimiter">);</span>
  <span class="Identifier">break</span><span class="Delimiter">;</span>
<span class="Delimiter">}</span>

<span class="Delimiter">:(scenario number_of_instructions)</span>
<span class="muRecipe">def</span> f1 [
  <span class="Constant">10</span>:num/child-id<span class="Special"> &lt;- </span>start-running f2
  <span class="Delimiter">{</span>
    loop-unless <span class="Constant">20</span>:num
  <span class="Delimiter">}</span>
  <span class="Constant">11</span>:num<span class="Special"> &lt;- </span>number-of-instructions <span class="Constant">10</span>:num
]
<span class="muRecipe">def</span> f2 [
  <span class="Comment"># 2 instructions worth of work</span>
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
  <span class="Constant">20</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">1</span>
]
<span class="Comment"># f2 runs an extra instruction for the implicit return added by the</span>
<span class="Comment"># fill_in_reply_ingredients transform</span>
<span class="traceContains">+mem: storing 3 in location 11</span>

<span class="Delimiter">:(scenario number_of_instructions_across_multiple_scheduling_intervals)</span>
<span class="Special">% Scheduling_interval = 1;</span>
<span class="muRecipe">def</span> f1 [
  <span class="Constant">10</span>:num/child-id<span class="Special"> &lt;- </span>start-running f2
  <span class="Delimiter">{</span>
    loop-unless <span class="Constant">20</span>:num
  <span class="Delimiter">}</span>
  <span class="Constant">11</span>:num<span class="Special"> &lt;- </span>number-of-instructions <span class="Constant">10</span>:num
]
<span class="muRecipe">def</span> f2 [
  <span class="Comment"># 4 instructions worth of work</span>
  <span class="Constant">1</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">34</span>
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">1</span>
  <span class="Constant">2</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">3</span>
  <span class="Constant">20</span>:num<span class="Special"> &lt;- </span>copy <span class="Constant">1</span>
]
<span class="Comment"># f2 runs an extra instruction for the implicit return added by the</span>
<span class="Comment"># fill_in_reply_ingredients transform</span>
<span class="traceContains">+mem: storing 5 in location 11</span>

<span class="SalientComment">//:: make sure that each routine gets a different alloc to start</span>

<span class="Delimiter">:(scenario new_concurrent)</span>
<span class="muRecipe">def</span> f1 [
  start-running f2
  <span class="Constant">1</span>:&amp;:num/<span class="Special">raw &lt;- </span><span class="Normal">new</span> <span class="Constant">number:type</span>
  <span class="Comment"># wait for f2 to complete</span>
  <span class="Delimiter">{</span>
    loop-unless <span class="Constant">4</span>:num/<span class="Special">raw</span>
  <span class="Delimiter">}</span>
]
<span class="muRecipe">def</span> f2 [
  <span class="Constant">2</span>:&amp;:num/<span class="Special">raw &lt;- </span><span class="Normal">new</span> <span class="Constant">number:type</span>
  <span class="Comment"># hack: assumes scheduler implementation</span>
  <span class="Constant">3</span>:<span class="Normal">bool</span>/<span class="Special">raw &lt;- </span>equal <span class="Constant">1</span>:&amp;:num/<span class="Special">raw</span><span class="Delimiter">,</span> <span class="Constant">2</span>:&amp;:num/<span class="Special">raw</span>
  <span class="Comment"># signal f2 complete</span>
  <span class="Constant">4</span>:num/<span class="Special">raw &lt;- </span>copy <span class="Constant">1</span>
]
<span class="traceContains">+mem: storing 0 in location 3</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
